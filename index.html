<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NeuroViz Pro ‚Äî Real Math Edition</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Exo+2:wght@300;600;800&display=swap');
:root{
  --bg:#111d2e;--panel:#172235;--border:#2a4060;--border2:#3a5878;
  --a1:#00ffe1;--a2:#ff3cac;--a3:#9b5dff;--a4:#ffb700;--a5:#00ff88;--a6:#ff4466;
  --text:#dff0ff;--dim:#7a9aba;--dim2:#4a6a8a;
}
*{margin:0;padding:0;box-sizing:border-box}
body{background:var(--bg);color:var(--text);font-family:'Exo 2',sans-serif;display:flex;height:100vh;overflow:hidden}

/* LEFT PANEL */
#left-panel{width:340px;min-width:340px;background:var(--panel);border-right:1px solid var(--border);display:flex;flex-direction:column;overflow:hidden;position:relative;z-index:10}
.ph{padding:12px 16px 8px;border-bottom:1px solid var(--border);flex-shrink:0}
.ph h1{font-family:'Share Tech Mono',monospace;font-size:14px;color:var(--a1);letter-spacing:2px;text-shadow:0 0 10px #00ffe166}
.ph p{font-size:9px;color:var(--dim2);font-family:'Share Tech Mono',monospace;letter-spacing:1px;margin-top:2px}

/* TABS */
.tab-bar{display:flex;border-bottom:1px solid var(--border);flex-shrink:0}
.tab{flex:1;padding:8px 2px;font-family:'Share Tech Mono',monospace;font-size:8.5px;letter-spacing:1px;text-align:center;cursor:pointer;color:var(--dim);border-bottom:2px solid transparent;transition:all .2s;text-transform:uppercase}
.tab.active{color:var(--a1);border-bottom-color:var(--a1)}
.tab-content{display:none;flex:1;overflow-y:auto;flex-direction:column}
.tab-content.active{display:flex;flex-direction:column}
.tab-content::-webkit-scrollbar{width:3px}
.tab-content::-webkit-scrollbar-thumb{background:var(--border)}

/* SECTIONS */
.sec{padding:10px 14px;border-bottom:1px solid var(--border)}
.slbl{font-family:'Share Tech Mono',monospace;font-size:8.5px;color:var(--dim2);letter-spacing:2.5px;text-transform:uppercase;margin-bottom:7px}

/* FORM */
.field{margin-bottom:8px}
.flbl{font-size:9.5px;color:var(--dim);font-family:'Share Tech Mono',monospace;margin-bottom:4px;display:flex;justify-content:space-between;align-items:center}
select{width:100%;background:#1a2e48;border:1px solid var(--border);color:var(--text);font-family:'Share Tech Mono',monospace;font-size:11px;padding:6px 28px 6px 9px;outline:none;border-radius:2px;appearance:none;cursor:pointer;transition:border-color .2s}
select:hover,select:focus{border-color:var(--a1)}
.sw{position:relative}.sw::after{content:'‚ñæ';position:absolute;right:8px;top:50%;transform:translateY(-50%);color:var(--a1);pointer-events:none;font-size:10px}
input[type=range]{width:100%;height:3px;background:var(--border);outline:none;-webkit-appearance:none;cursor:pointer;border-radius:2px}
input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:12px;height:12px;background:var(--a1);border-radius:50%;box-shadow:0 0 5px var(--a1);cursor:pointer}
.vbadge{background:#1a2e48;border:1px solid var(--border);padding:2px 6px;font-family:'Share Tech Mono',monospace;font-size:10px;color:var(--a1);border-radius:2px;min-width:48px;text-align:center}

/* BUTTONS */
.btn-row{display:flex;gap:5px;padding:8px 14px;border-bottom:1px solid var(--border);flex-shrink:0}
.btn{flex:1;padding:8px 4px;border:1px solid;font-family:'Share Tech Mono',monospace;font-size:9px;letter-spacing:1px;text-transform:uppercase;cursor:pointer;background:transparent;border-radius:2px;transition:all .15s}
.bc{border-color:var(--a1);color:var(--a1)}.bc:hover,.bc.act{background:var(--a1);color:#0a1628;box-shadow:0 0 10px #00ffe166}
.bg{border-color:var(--a5);color:var(--a5)}.bg:hover{background:var(--a5);color:#111}
.br{border-color:var(--a6);color:var(--a6)}.br:hover{background:var(--a6);color:#fff}
.bp{border-color:var(--a2);color:var(--a2)}.bp:hover{background:var(--a2);color:#fff}
.bpu{border-color:var(--a3);color:var(--a3)}.bpu:hover{background:var(--a3);color:#fff}
.bc.pulse{animation:pulse 1s ease-in-out infinite}
@keyframes pulse{0%,100%{box-shadow:0 0 5px var(--a1)}50%{box-shadow:0 0 18px var(--a1)}}

/* TOGGLE */
.trow{display:flex;justify-content:space-between;align-items:center;margin-bottom:7px}
.tlbl{font-size:9.5px;color:var(--dim);font-family:'Share Tech Mono',monospace;letter-spacing:.5px}
.tsw{position:relative;width:32px;height:16px;cursor:pointer}
.tsw input{display:none}
.ttrack{position:absolute;inset:0;background:var(--border);border-radius:16px;transition:background .2s}
.tthumb{position:absolute;height:10px;width:10px;left:3px;bottom:3px;background:var(--dim2);border-radius:50%;transition:transform .2s,background .2s}
.tsw input:checked+.ttrack{background:#00ffe120;border:1px solid var(--a1)}
.tsw input:checked+.ttrack .tthumb{transform:translateX(16px);background:var(--a1);box-shadow:0 0 4px var(--a1)}

/* STATS */
.sg{display:grid;grid-template-columns:1fr 1fr;gap:5px}
.sb{background:#1a2e48;border:1px solid var(--border);padding:6px 9px;border-radius:2px}
.sk{font-family:'Share Tech Mono',monospace;font-size:8.5px;color:var(--dim);letter-spacing:.5px}
.sv{font-family:'Share Tech Mono',monospace;font-size:13px;font-weight:700;margin-top:1px}
.c1{color:var(--a1)}.c2{color:var(--a2)}.c3{color:var(--a3)}.c4{color:var(--a4)}.c5{color:var(--a5)}.c6{color:var(--a6)}

/* CHARTS */
.mc{display:block;width:100%;height:55px;margin-top:4px}

/* INFO */
.info{font-family:'Share Tech Mono',monospace;font-size:9px;color:var(--dim);line-height:1.7}
.info span{color:var(--text)}
.math-box{background:#0e1e30;border:1px solid var(--border);padding:7px 10px;border-radius:3px;font-family:'Share Tech Mono',monospace;font-size:9px;color:var(--a3);line-height:1.9;margin-top:5px}
.math-box .label{color:var(--dim2);font-size:8px}

/* RIGHT */
#right-panel{flex:1;position:relative;overflow:hidden;cursor:grab}
#right-panel.dragging{cursor:grabbing}
#right-panel.panning{cursor:move}
#three-canvas,#overlay{position:absolute;top:0;left:0;width:100%;height:100%}
#overlay{pointer-events:none;z-index:5}

/* HUD */
#hud{position:absolute;top:12px;right:12px;pointer-events:none;font-family:'Share Tech Mono',monospace;font-size:10px;color:var(--dim);text-align:right;letter-spacing:1px;line-height:1.9}
#hud .ht{font-size:13px;color:var(--a1);text-shadow:0 0 10px #00ffe166;letter-spacing:3px}
#hud .he{color:var(--a4);font-size:11px}

/* LEGEND */
#legend{position:absolute;top:12px;left:12px;pointer-events:none;font-family:'Share Tech Mono',monospace;font-size:9px;color:var(--dim);letter-spacing:.5px}
.lr{display:flex;align-items:center;gap:6px;margin-bottom:4px}
.ll{width:18px;height:2px;border-radius:1px}
.ld{width:8px;height:8px;border-radius:50%}

/* PHASE BANNER */
#pbanner{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:3px;padding:5px 14px;border:1px solid;pointer-events:none;opacity:0;transition:opacity .3s;z-index:20;text-transform:uppercase}
#pbanner.show{opacity:1}
#pbanner.forward{color:#9b5dff;border-color:#9b5dff;background:#9b5dff18;box-shadow:0 0 18px #9b5dff44}
#pbanner.backward{color:#ffb700;border-color:#ffb700;background:#ffb70018;box-shadow:0 0 18px #ffb70044}
#pbanner.update{color:#00ffe1;border-color:#00ffe1;background:#00ffe118;box-shadow:0 0 18px #00ffe144}

/* WEIGHT DETAIL BAR */
#wbar{position:absolute;bottom:34px;left:50%;transform:translateX(-50%);background:#0e1e30f2;border:1px solid var(--border2);font-family:'Share Tech Mono',monospace;font-size:9.5px;color:var(--text);padding:8px 14px;pointer-events:none;z-index:30;border-radius:3px;display:none;gap:16px;align-items:center;white-space:nowrap;box-shadow:0 4px 24px #00000060}
.wc{display:flex;flex-direction:column;gap:2px}
.wl{color:var(--dim);font-size:8px;letter-spacing:1.5px}
.wv{font-size:12px;font-weight:700}
.wa{font-size:15px;color:var(--border2)}

/* TOOLTIP */
#tip{position:absolute;background:#0e1e30ee;border:1px solid var(--a1);padding:7px 10px;font-family:'Share Tech Mono',monospace;font-size:9.5px;color:var(--a1);pointer-events:none;display:none;z-index:100;border-radius:2px;line-height:1.7;max-width:200px}

/* ATTN PANEL */
#attn-panel{position:absolute;top:60px;left:50%;transform:translateX(-50%);background:#0e1e30f2;border:1px solid var(--a2);padding:10px;pointer-events:all;display:none;z-index:25;border-radius:3px;box-shadow:0 0 20px #ff3cac20}
#attn-panel h3{font-family:'Share Tech Mono',monospace;font-size:9px;color:var(--a2);letter-spacing:2px;margin-bottom:6px}
#attn-close{position:absolute;top:5px;right:8px;cursor:pointer;color:var(--a6);font-size:12px}

/* STATUS BAR */
#sb{position:absolute;bottom:0;left:0;right:0;height:28px;background:#0d1e30;border-top:1px solid var(--border);display:flex;align-items:center;padding:0 12px;gap:18px;font-family:'Share Tech Mono',monospace;font-size:9px;color:var(--dim);z-index:30}
.sd{width:5px;height:5px;border-radius:50%;background:var(--dim)}
.sd.on{background:var(--a5);box-shadow:0 0 5px var(--a5);animation:blink 1s infinite}
@keyframes blink{0%,100%{opacity:1}50%{opacity:.3}}
.si{display:flex;align-items:center;gap:5px}
.cam-hint{position:absolute;bottom:32px;right:12px;font-family:'Share Tech Mono',monospace;font-size:8px;color:var(--dim2);letter-spacing:.5px;pointer-events:none;line-height:2;text-align:right}
</style>
</head>
<body>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê LEFT PANEL ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div id="left-panel">
  <div class="ph">
    <h1>‚¨° NEURO¬∑VIZ PRO</h1>
    <p>// REAL MATH EDITION ‚Äî v4.0</p>
  </div>

  <div class="tab-bar">
    <div class="tab active" data-tab="config">CONFIG</div>
    <div class="tab" data-tab="math">MATH</div>
    <div class="tab" data-tab="train">TRAIN</div>
    <div class="tab" data-tab="inspect">INSPECT</div>
  </div>

  <!-- CONFIG TAB -->
  <div class="tab-content active" id="tab-config">
    <div class="sec">
      <div class="slbl">Dataset</div>
      <div class="field">
        <div class="sw"><select id="ds-sel">
          <optgroup label="‚îÄ‚îÄ CLASSIFICATION (Real labels) ‚îÄ‚îÄ">
            <option value="xor">XOR (4 points, 2 classes)</option>
            <option value="iris">Iris (4 features ‚Üí 3 species)</option>
            <option value="moons" selected>Two Moons (400 pts)</option>
            <option value="spiral">Spiral (300 pts, 3 classes)</option>
            <option value="circles">Circles (400 pts)</option>
            <option value="blobs">Gaussian Blobs (300 pts)</option>
            <option value="checkerboard">Checkerboard (400 pts)</option>
          </optgroup>
          <optgroup label="‚îÄ‚îÄ IMAGE (Simulated) ‚îÄ‚îÄ">
            <option value="mnist_sim">MNIST Digits (784D ‚Üí 10)</option>
            <option value="cifar_sim">CIFAR-10 (3072D ‚Üí 10)</option>
            <option value="fashion_sim">Fashion MNIST (784D ‚Üí 10)</option>
          </optgroup>
          <optgroup label="‚îÄ‚îÄ SEQUENCE (Real task) ‚îÄ‚îÄ">
            <option value="sine">Sine Wave Regression</option>
            <option value="stock_sim">Time Series (stock prices)</option>
            <option value="parity">Bit Parity (LSTM)</option>
            <option value="copy">Copy Sequence (LSTM)</option>
          </optgroup>
          <optgroup label="‚îÄ‚îÄ LANGUAGE (Simulated) ‚îÄ‚îÄ">
            <option value="char_lm">Character LM (26 letters)</option>
            <option value="word_embed">Word Embeddings (100 vocab)</option>
            <option value="sentiment">Sentiment Analysis (128D)</option>
          </optgroup>
          <optgroup label="‚îÄ‚îÄ ATTENTION (Real task) ‚îÄ‚îÄ">
            <option value="attn_sort">Sort Sequence (MHA)</option>
            <option value="attn_assoc">Associative Recall (MHA)</option>
          </optgroup>
          <optgroup label="‚îÄ‚îÄ GENERATIVE ‚îÄ‚îÄ">
            <option value="vae_data">VAE Dataset (2D clusters)</option>
            <option value="gan_data">GAN Dataset (2D spiral)</option>
          </optgroup>
        </select></div>
      </div>
      <div class="info" id="ds-info"></div>
    </div>

    <div class="sec">
      <div class="slbl">Network Architecture</div>
      <div class="field">
        <div class="sw"><select id="net-sel">
          <optgroup label="‚îÄ‚îÄ FEEDFORWARD ‚îÄ‚îÄ">
            <option value="mlp2" selected>MLP 2-layer (2‚Üí8‚Üí1)</option>
            <option value="mlp3">MLP 3-layer (2‚Üí16‚Üí8‚Üí3)</option>
            <option value="deep">Deep MLP (2‚Üí32‚Üí16‚Üí8‚Üí3)</option>
            <option value="wide">Wide MLP (2‚Üí64‚Üí64‚Üí2)</option>
            <option value="bottleneck">Bottleneck (8‚Üí16‚Üí4‚Üí16‚Üí8)</option>
            <option value="resnet">ResNet-style (deep with skips)</option>
          </optgroup>
          <optgroup label="‚îÄ‚îÄ RECURRENT ‚îÄ‚îÄ">
            <option value="lstm">LSTM (real gates)</option>
            <option value="gru">GRU (real gates)</option>
            <option value="birnn">Bidirectional RNN</option>
          </optgroup>
          <optgroup label="‚îÄ‚îÄ ATTENTION ‚îÄ‚îÄ">
            <option value="mha">Multi-Head Attention (real QKV)</option>
            <option value="transformer">Transformer Block</option>
            <option value="gpt">GPT-style Decoder</option>
          </optgroup>
          <optgroup label="‚îÄ‚îÄ GENERATIVE ‚îÄ‚îÄ">
            <option value="vae">VAE (Variational Autoencoder)</option>
            <option value="autoencoder">Autoencoder</option>
          </optgroup>
        </select></div>
      </div>
      <div class="info" id="net-info"></div>
    </div>

    <div class="sec">
      <div class="slbl">Training Config</div>
      <div class="field">
        <div class="flbl">OPTIMIZER</div>
        <div class="sw"><select id="opt-sel">
          <option value="sgd">SGD</option>
          <option value="momentum">SGD + Momentum</option>
          <option value="rmsprop">RMSProp</option>
          <option value="adam" selected>Adam (Œ≤‚ÇÅ=0.9, Œ≤‚ÇÇ=0.999)</option>
          <option value="adamw">AdamW (with weight decay)</option>
        </select></div>
      </div>
      <div class="field">
        <div class="flbl">LOSS FUNCTION</div>
        <div class="sw"><select id="loss-sel">
          <option value="bce">Binary Cross-Entropy</option>
          <option value="cce" selected>Categorical Cross-Entropy</option>
          <option value="mse">Mean Squared Error</option>
        </select></div>
      </div>
      <div class="field">
        <div class="flbl">LEARNING RATE <span class="vbadge" id="lr-v">0.010</span></div>
        <input type="range" id="lr-sl" min="-4" max="-0.5" step="0.01" value="-2">
      </div>
      <div class="field">
        <div class="flbl">BATCH SIZE <span class="vbadge" id="bs-v">32</span></div>
        <input type="range" id="bs-sl" min="0" max="5" step="1" value="3">
      </div>
      <div class="field">
        <div class="flbl">ANIM SPEED <span class="vbadge" id="sp-v">1.0√ó</span></div>
        <input type="range" id="sp-sl" min="0.2" max="5" step="0.1" value="1">
      </div>
    </div>

    <div class="sec">
      <div class="slbl">Display</div>
      <div class="trow"><span class="tlbl">SHOW WEIGHT NUMBERS</span><label class="tsw"><input type="checkbox" id="tog-wn" checked><div class="ttrack"><div class="tthumb"></div></div></label></div>
      <div class="trow"><span class="tlbl">SHOW ACTIVATIONS</span><label class="tsw"><input type="checkbox" id="tog-act" checked><div class="ttrack"><div class="tthumb"></div></div></label></div>
      <div class="trow"><span class="tlbl">SHOW GRADIENTS</span><label class="tsw"><input type="checkbox" id="tog-grad" checked><div class="ttrack"><div class="tthumb"></div></div></label></div>
      <div class="trow"><span class="tlbl">ATTENTION HEATMAP</span><label class="tsw"><input type="checkbox" id="tog-attn"><div class="ttrack"><div class="tthumb"></div></div></label></div>
      <div class="trow"><span class="tlbl">AUTO-ORBIT 3D</span><label class="tsw"><input type="checkbox" id="tog-3d"><div class="ttrack"><div class="tthumb"></div></div></label></div>
    </div>
  </div>

  <!-- MATH TAB -->
  <div class="tab-content" id="tab-math">
    <div class="sec">
      <div class="slbl">Current Formulas</div>
      <div id="math-display"></div>
    </div>
    <div class="sec">
      <div class="slbl">Step-by-Step Log</div>
      <div id="math-log" style="font-family:'Share Tech Mono',monospace;font-size:8.5px;color:var(--dim);line-height:1.9;max-height:300px;overflow-y:auto"></div>
    </div>
    <div class="sec">
      <div class="slbl">Spotlight Weight</div>
      <div id="spotlight-math" class="math-box"></div>
    </div>
  </div>

  <!-- TRAIN TAB -->
  <div class="tab-content" id="tab-train">
    <div class="sec">
      <div class="slbl">Live Stats</div>
      <div class="sg">
        <div class="sb"><div class="sk">EPOCH</div><div class="sv c1" id="s-epoch">0</div></div>
        <div class="sb"><div class="sk">STEP</div><div class="sv c1" id="s-step">0</div></div>
        <div class="sb"><div class="sk">LOSS</div><div class="sv c4" id="s-loss">‚Äî</div></div>
        <div class="sb"><div class="sk">ACCURACY</div><div class="sv c5" id="s-acc">‚Äî</div></div>
        <div class="sb"><div class="sk">|‚àá| NORM</div><div class="sv c2" id="s-grad">‚Äî</div></div>
        <div class="sb"><div class="sk">WEIGHT Œî</div><div class="sv c3" id="s-delta">‚Äî</div></div>
        <div class="sb"><div class="sk">PARAMS</div><div class="sv c1" id="s-params">‚Äî</div></div>
        <div class="sb"><div class="sk">SAMPLES</div><div class="sv c5" id="s-samples">‚Äî</div></div>
      </div>
    </div>
    <div class="sec">
      <div class="slbl">Loss Curve (real convergence)</div>
      <canvas class="mc" id="loss-chart" height="55"></canvas>
    </div>
    <div class="sec">
      <div class="slbl">Accuracy Curve</div>
      <canvas class="mc" id="acc-chart" height="50"></canvas>
    </div>
    <div class="sec">
      <div class="slbl">Gradient Norms per Layer</div>
      <div id="grad-bars"></div>
    </div>
    <div class="sec">
      <div class="slbl">Weight Distribution</div>
      <canvas class="mc" id="wdist-chart" height="50"></canvas>
    </div>
    <div class="sec">
      <div class="slbl">Decision Boundary</div>
      <canvas id="db-canvas" width="280" height="220" style="display:block;margin:0 auto;border:1px solid var(--border);border-radius:2px"></canvas>
      <div class="info" style="margin-top:4px">Live decision boundary on training data.</div>
    </div>
    <div class="sec">
      <div class="slbl">Export</div>
      <div style="display:flex;gap:5px;flex-direction:column">
        <button class="btn bc" id="btn-png" style="width:100%;padding:8px">üì∑ SCREENSHOT PNG</button>
        <button class="btn bg" id="btn-csv" style="width:100%;padding:8px">üìä EXPORT METRICS CSV</button>
      </div>
    </div>
  </div>

  <!-- INSPECT TAB -->
  <div class="tab-content" id="tab-inspect">
    <div class="sec">
      <div class="slbl">Layer Inspector</div>
      <div id="layer-inspect"></div>
    </div>
    <div class="sec">
      <div class="slbl">LSTM Gate Values</div>
      <div id="lstm-gates" class="info">Run LSTM network to see gate activations.</div>
    </div>
    <div class="sec">
      <div class="slbl">Attention Scores</div>
      <div id="attn-scores" class="info">Run MHA network to see attention weights.</div>
    </div>
    <div class="sec">
      <div class="slbl">Keyboard Shortcuts</div>
      <div class="info">
        <span>SPACE</span> ‚Äî Play/Pause<br>
        <span>N</span> ‚Äî Single step<br>
        <span>R</span> ‚Äî Reset<br>
        <span>A</span> ‚Äî Attention panel<br>
        <span>+/-</span> ‚Äî Zoom<br>
        <span>0</span> ‚Äî Reset camera<br>
        <span>Arrows</span> ‚Äî Pan<br>
        <span>ESC</span> ‚Äî Close panels
      </div>
    </div>
  </div>
</div>

<!-- CONTROL BUTTONS (fixed bottom) -->
<div style="position:absolute;left:0;bottom:0;width:340px;z-index:20">
  <div class="btn-row" style="background:var(--panel);border-top:1px solid var(--border)">
    <button class="btn bc" id="btn-play">‚ñ∂ PLAY</button>
    <button class="btn bpu" id="btn-step">‚ü´ STEP</button>
    <button class="btn bp" id="btn-pause">‚è∏ PAUSE</button>
    <button class="btn br" id="btn-reset">‚äò RESET</button>
  </div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê RIGHT PANEL ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div id="right-panel">
  <canvas id="three-canvas"></canvas>
  <canvas id="overlay"></canvas>
  <div id="pbanner"></div>

  <div id="hud">
    <div class="ht" id="hud-title">SELECT NETWORK</div>
    <div id="hud-net" style="color:var(--dim)">‚Äî</div>
    <div id="hud-ds" style="color:var(--dim)">‚Äî</div>
    <div class="he" id="hud-epoch">EPOCH 0</div>
  </div>

  <div id="legend">
    <div class="lr"><div class="ll" style="background:#00ffe1;box-shadow:0 0 4px #00ffe1"></div>Positive Weight</div>
    <div class="lr"><div class="ll" style="background:#ff4466;box-shadow:0 0 4px #ff4466"></div>Negative Weight</div>
    <div class="lr"><div class="ll" style="background:#ffb700;box-shadow:0 0 4px #ffb700"></div>Gradient ‚àá</div>
    <div class="lr"><div class="ld" style="background:#9b5dff;box-shadow:0 0 4px #9b5dff"></div>Activation Flow</div>
  </div>

  <div id="wbar">
    <div class="wc"><div class="wl">WEIGHT</div><div class="wv c1" id="wb-id">‚Äî</div></div>
    <div class="wc"><div class="wl">OLD w</div><div class="wv" id="wb-old">‚Äî</div></div>
    <div class="wa">‚Üí</div>
    <div class="wc"><div class="wl">‚àá GRAD</div><div class="wv c4" id="wb-g">‚Äî</div></div>
    <div class="wc"><div class="wl">Œîw = ‚àílr¬∑‚àá</div><div class="wv c2" id="wb-d">‚Äî</div></div>
    <div class="wa">‚Üí</div>
    <div class="wc"><div class="wl">NEW w</div><div class="wv c5" id="wb-n">‚Äî</div></div>
  </div>

  <div id="attn-panel">
    <div id="attn-close">‚úï</div>
    <h3>ATTENTION SCORES  Q¬∑K·µÄ/‚àöd‚Çñ ‚Üí softmax</h3>
    <canvas id="attn-canvas" width="200" height="200"></canvas>
    <div class="info" id="attn-info" style="margin-top:5px;font-size:8px"></div>
  </div>

  <div id="tip"></div>
  <div class="cam-hint">üñ± Drag orbit ¬∑ Shift+Drag pan ¬∑ Scroll zoom ¬∑ Dbl-click reset</div>

  <div id="sb">
    <div class="si"><div class="sd" id="sb-dot"></div><span id="sb-st">IDLE</span></div>
    <div class="si">‚äï <span id="sb-n">0</span></div>
    <div class="si">‚äû <span id="sb-c">0</span></div>
    <div class="si">‚óâ <span id="sb-ph">‚Äî</span></div>
    <div class="si" style="margin-left:auto;color:var(--dim2)">REAL MATH v4.0</div>
  </div>
</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  UTILITIES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const rng=()=>Math.random();
const randn=()=>{let u=0,v=0;while(!u)u=rng();while(!v)v=rng();return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);}
const clip=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
const sum=a=>a.reduce((s,v)=>s+v,0);
const dot=(a,b)=>a.reduce((s,v,i)=>s+v*b[i],0);

// ‚îÄ‚îÄ Activations ‚îÄ‚îÄ
const sigmoid=x=>1/(1+Math.exp(-clip(x,-30,30)));
const tanh=x=>Math.tanh(x);
const relu=x=>Math.max(0,x);
const reluD=x=>x>0?1:0;
const sigmoidD=x=>{const s=sigmoid(x);return s*(1-s);}
const tanhD=x=>1-Math.tanh(x)**2;

// ‚îÄ‚îÄ Softmax (numerically stable) ‚îÄ‚îÄ
function softmax(a){
  const mx=Math.max(...a);
  const ex=a.map(v=>Math.exp(v-mx));
  const s=sum(ex);
  return ex.map(v=>v/s);
}

// ‚îÄ‚îÄ Matrix ops ‚îÄ‚îÄ
function matMul(A,B){
  // A: [m√ók], B: [k√ón] ‚Üí [m√ón]
  const m=A.length,k=A[0].length,n=B[0].length;
  const C=Array.from({length:m},()=>new Array(n).fill(0));
  for(let i=0;i<m;i++) for(let j=0;j<n;j++) for(let p=0;p<k;p++) C[i][j]+=A[i][p]*B[p][j];
  return C;
}
function matVec(W,x){return W.map(row=>dot(row,x));}
function vecAdd(a,b){return a.map((v,i)=>v+b[i]);}
function vecScale(a,s){return a.map(v=>v*s);}
function outerProduct(a,b){return a.map(ai=>b.map(bi=>ai*bi));}
function transpose(A){return A[0].map((_,j)=>A.map(row=>row[j]));}
function zeros(n){return new Array(n).fill(0);}
function zeros2d(r,c){return Array.from({length:r},()=>new Array(c).fill(0));}
function xavierW(fi,fo){
  const s=Math.sqrt(2/(fi+fo));
  return Array.from({length:fo},()=>Array.from({length:fi},()=>randn()*s));
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  DATASET GENERATORS  (real labels)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const DATASETS = {
  xor:{
    name:'XOR',desc:'4 canonical XOR points. Requires non-linear separator.',
    inputDim:2,outputDim:1,task:'bce',
    generate(){
      return {X:[[0,0],[0,1],[1,0],[1,1]],y:[0,1,1,0]};
    }
  },
  moons:{
    name:'Two Moons',desc:'Two interleaved half-circles, 400 pts. Tests curved boundaries.',
    inputDim:2,outputDim:2,task:'cce',
    generate(n=400){
      const X=[],y=[];
      for(let i=0;i<n/2;i++){
        const t=(i/(n/2))*Math.PI;
        X.push([Math.cos(t)+randn()*.1, Math.sin(t)+randn()*.1]); y.push(0);
        X.push([1-Math.cos(t)+randn()*.1, -Math.sin(t)-.5+randn()*.1]); y.push(1);
      }
      return {X,y};
    }
  },
  spiral:{
    name:'3-class Spiral',desc:'300 pts, 3 interleaved spirals. Needs deep non-linearity.',
    inputDim:2,outputDim:3,task:'cce',
    generate(n=300){
      const X=[],y=[];
      for(let c=0;c<3;c++){
        for(let i=0;i<n/3;i++){
          const t=i/(n/3)*4*Math.PI+c*(2*Math.PI/3);
          const r=i/(n/3)*1.5;
          X.push([r*Math.sin(t)+randn()*.08, r*Math.cos(t)+randn()*.08]);
          y.push(c);
        }
      }
      return {X,y};
    }
  },
  circles:{
    name:'Concentric Circles',desc:'Inner vs outer ring, 400 pts.',
    inputDim:2,outputDim:2,task:'cce',
    generate(n=400){
      const X=[],y=[];
      for(let i=0;i<n;i++){
        const angle=rng()*2*Math.PI;
        const r=i<n/2?rng()*.5:(0.7+rng()*.3);
        X.push([r*Math.cos(angle)+randn()*.05, r*Math.sin(angle)+randn()*.05]);
        y.push(i<n/2?0:1);
      }
      return {X,y};
    }
  },
  blobs:{
    name:'Gaussian Blobs',desc:'3 isotropic Gaussian clusters, 300 pts.',
    inputDim:2,outputDim:3,task:'cce',
    generate(n=300){
      const centers=[[-1,0],[1,-.7],[0,1.2]];
      const X=[],y=[];
      for(let c=0;c<3;c++) for(let i=0;i<n/3;i++){X.push([centers[c][0]+randn()*.35,centers[c][1]+randn()*.35]);y.push(c);}
      return {X,y};
    }
  },
  checkerboard:{
    name:'Checkerboard',desc:'4√ó4 checkerboard binary pattern. Tests complex boundaries.',
    inputDim:2,outputDim:2,task:'cce',
    generate(n=400){
      const X=[],y=[];
      for(let i=0;i<n;i++){
        const x=(rng()*2-1),z=(rng()*2-1);
        const cls=((Math.floor((x+1)*2)+Math.floor((z+1)*2))%2);
        X.push([x+randn()*.04,z+randn()*.04]);y.push(cls);
      }
      return {X,y};
    }
  },
  sine:{
    name:'Sine Regression',desc:'Predict sin(x) from x ‚àà [-œÄ,œÄ]. Regression task.',
    inputDim:1,outputDim:1,task:'mse',
    generate(n=200){
      const X=[],y=[];
      for(let i=0;i<n;i++){const x=(i/n)*2*Math.PI-Math.PI;X.push([x]);y.push(Math.sin(x));}
      return {X,y};
    }
  },
  parity:{
    name:'Bit Parity (LSTM)',desc:'8-bit sequence: predict XOR parity at each step. Requires memory.',
    inputDim:1,outputDim:1,task:'bce',seqLen:8,
    generate(n=200){
      const X=[],y=[];
      for(let i=0;i<n;i++){const bits=Array.from({length:8},()=>Math.round(rng()));const parity=bits.reduce((a,b)=>a^b,0);X.push(bits.map(b=>[b]));y.push([parity]);}
      return {X,y,seq:true};
    }
  },
  copy:{
    name:'Copy Sequence (LSTM)',desc:'Memorize 5-token sequence, reproduce after blank tokens.',
    inputDim:4,outputDim:4,task:'cce',seqLen:10,
    generate(n=100){
      const X=[],y=[];
      const V=4;
      for(let i=0;i<n;i++){
        const seq=Array.from({length:5},()=>Math.floor(rng()*V));
        const inp=[...seq.map(t=>Array.from({length:V},(_,k)=>k===t?1:0)),...Array(5).fill(Array(V).fill(0))];
        const out=[...Array(5).fill(Array(V).fill(0)),...seq.map(t=>Array.from({length:V},(_,k)=>k===t?1:0))];
        X.push(inp);y.push(out);
      }
      return {X,y,seq:true};
    }
  },
  attn_sort:{
    name:'Sort Sequence (MHA)',desc:'Sort 4 tokens by value. Attention selects min/max.',
    inputDim:4,outputDim:4,task:'mse',seqLen:4,
    generate(n=200){
      const X=[],y=[];
      for(let i=0;i<n;i++){const s=Array.from({length:4},()=>rng());X.push(s);y.push([...s].sort((a,b)=>a-b));}
      return {X,y};
    }
  },
  attn_assoc:{
    name:'Associative Recall (MHA)',desc:'Given key‚Üívalue pairs, retrieve value for query key.',
    inputDim:8,outputDim:4,task:'mse',
    generate(n=200){
      const X=[],y=[];
      for(let i=0;i<n;i++){const x=Array.from({length:8},()=>rng());X.push(x);y.push(x.slice(0,4).map(v=>v>.5?1:0));}
      return {X,y};
    }
  },
  iris:{
    name:'Iris',desc:'4 features (sepal/petal) ‚Üí 3 species. Classic ML.',
    inputDim:4,outputDim:3,task:'cce',
    generate(n=150){
      const X=[],y=[];
      const means=[[5.0,3.4,1.5,0.2],[6.0,2.8,4.5,1.5],[6.5,3.0,5.5,2.0]];
      for(let c=0;c<3;c++)for(let i=0;i<n/3;i++){
        X.push(means[c].map((m,j)=>m+randn()*.4));y.push(c);
      }
      return {X,y};
    }
  },
  mnist_sim:{
    name:'MNIST (sim)',desc:'784-dim ‚Üí 10 digits. Simulated.',
    inputDim:784,outputDim:10,task:'cce',
    generate(n=200){
      const X=[],y=[];
      for(let i=0;i<n;i++){
        const digit=Math.floor(rng()*10);
        const vec=Array.from({length:784},(_,j)=>Math.sin(digit+j*.01)*Math.cos(j*.02)+randn()*.3);
        X.push(vec);y.push(digit);
      }
      return {X,y};
    }
  },
  cifar_sim:{
    name:'CIFAR-10 (sim)',desc:'3072-dim ‚Üí 10 classes.',
    inputDim:3072,outputDim:10,task:'cce',
    generate(n=200){
      const X=[],y=[];
      for(let i=0;i<n;i++){
        const cls=Math.floor(rng()*10);
        const vec=Array.from({length:3072},(_,j)=>(cls*.1+Math.sin(j*.005))*randn()*.5);
        X.push(vec);y.push(cls);
      }
      return {X,y};
    }
  },
  fashion_sim:{
    name:'Fashion MNIST (sim)',desc:'784-dim clothing ‚Üí 10 classes.',
    inputDim:784,outputDim:10,task:'cce',
    generate(n=200){
      const X=[],y=[];
      for(let i=0;i<n;i++){
        const cls=Math.floor(rng()*10);
        const vec=Array.from({length:784},(_,j)=>Math.cos(cls*j*.003)+randn()*.4);
        X.push(vec);y.push(cls);
      }
      return {X,y};
    }
  },
  stock_sim:{
    name:'Time Series',desc:'Predict next 5 from prev 20. Random walk.',
    inputDim:20,outputDim:5,task:'mse',
    generate(n=200){
      const X=[],y=[];
      for(let i=0;i<n;i++){
        const walk=[100];
        for(let j=1;j<25;j++)walk.push(walk[j-1]+randn()*2);
        X.push(walk.slice(0,20));y.push(walk.slice(20));
      }
      return {X,y};
    }
  },
  char_lm:{
    name:'Character LM',desc:'Next-char prediction. 26-letter vocab.',
    inputDim:26,outputDim:26,task:'cce',
    generate(n=200){
      const X=[],y=[];
      for(let i=0;i<n;i++){
        const c1=Math.floor(rng()*26),c2=(c1+Math.floor(rng()*3)+1)%26;
        const vec=Array(26).fill(0);vec[c1]=1;
        X.push(vec);y.push(c2);
      }
      return {X,y};
    }
  },
  word_embed:{
    name:'Word Embeddings',desc:'Skip-gram style. 100-word vocab.',
    inputDim:100,outputDim:100,task:'cce',
    generate(n=200){
      const X=[],y=[];
      for(let i=0;i<n;i++){
        const w=Math.floor(rng()*100);const ctx=(w+Math.floor(rng()*10)-5+100)%100;
        const vec=Array(100).fill(0);vec[w]=1;
        X.push(vec);y.push(ctx);
      }
      return {X,y};
    }
  },
  sentiment:{
    name:'Sentiment',desc:'128-dim bag-of-words ‚Üí pos/neg.',
    inputDim:128,outputDim:2,task:'cce',
    generate(n=200){
      const X=[],y=[];
      for(let i=0;i<n;i++){
        const cls=Math.round(rng());
        const vec=Array.from({length:128},(_,j)=>(cls===1?1:-1)*Math.abs(randn()*.5)+randn()*.2);
        X.push(vec);y.push(cls);
      }
      return {X,y};
    }
  },
  vae_data:{
    name:'VAE Dataset',desc:'2D point cloud. Clustered Gaussians.',
    inputDim:2,outputDim:2,task:'mse',
    generate(n=300){
      const X=[],y=[];
      for(let i=0;i<n;i++){
        const c=Math.floor(rng()*3);
        const centers=[[0,0],[2,2],[-2,2]];
        const p=[centers[c][0]+randn()*.5,centers[c][1]+randn()*.5];
        X.push(p);y.push(p);
      }
      return {X,y};
    }
  },
  gan_data:{
    name:'GAN Dataset',desc:'2D spiral for GAN discriminator training.',
    inputDim:2,outputDim:1,task:'bce',
    generate(n=300){
      const X=[],y=[];
      for(let i=0;i<n;i++){
        const t=(i/n)*4*Math.PI;
        const r=t*.2;
        X.push([r*Math.sin(t)+randn()*.1,r*Math.cos(t)+randn()*.1]);
        y.push(1);
      }
      return {X,y};
    }
  }
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  NETWORK DEFINITIONS WITH REAL FORWARD / BACKWARD
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚îÄ‚îÄ MLP with real backprop ‚îÄ‚îÄ
class MLP {
  constructor(dims){
    this.dims=dims;
    this.W=[];this.b=[];this.dW=[];this.db=[];
    for(let i=0;i<dims.length-1;i++){
      this.W.push(xavierW(dims[i],dims[i+1]));
      this.b.push(zeros(dims[i+1]));
      this.dW.push(zeros2d(dims[i+1],dims[i]));
      this.db.push(zeros(dims[i+1]));
    }
    this.cache={z:[],a:[]};
  }
  forward(x){
    this.cache.z=[];this.cache.a=[x.slice()];
    let h=x.slice();
    for(let l=0;l<this.W.length;l++){
      const z=vecAdd(matVec(this.W[l],h),this.b[l]);
      this.cache.z.push(z);
      const isLast=l===this.W.length-1;
      h=isLast?z:z.map(relu); // last layer raw (loss applies activation)
      this.cache.a.push(h.slice());
    }
    return h;
  }
  backward(dLoss){
    // dLoss: gradient of loss w.r.t. output (pre-softmax for CCE, post-sigmoid for BCE, raw for MSE)
    let delta=dLoss.slice();
    for(let l=this.W.length-1;l>=0;l--){
      const aL=this.cache.a[l];
      // Compute weight gradients
      for(let j=0;j<this.W[l].length;j++)
        for(let k=0;k<this.W[l][j].length;k++)
          this.dW[l][j][k]=delta[j]*aL[k];
      this.db[l]=delta.slice();
      // Propagate delta
      if(l>0){
        const newDelta=zeros(aL.length);
        for(let k=0;k<aL.length;k++)
          for(let j=0;j<this.W[l].length;j++)
            newDelta[k]+=this.W[l][j][k]*delta[j];
        // Apply activation derivative (ReLU for hidden)
        delta=newDelta.map((d,k)=>d*reluD(this.cache.z[l-1][k]));
      }
    }
    return delta;
  }
  params(){let p=0;this.W.forEach((w,i)=>{p+=w.length*w[0].length+this.b[i].length;});return p;}
}

// ‚îÄ‚îÄ Real LSTM ‚îÄ‚îÄ
class LSTMCell {
  constructor(inputSize,hiddenSize){
    this.inputSize=inputSize;this.hiddenSize=hiddenSize;
    const n=hiddenSize,m=inputSize;
    // 4 gate weight matrices: i(input), f(forget), g(cell), o(output)
    this.Wf=xavierW(n+m,n); this.bf=zeros(n); // forget gate
    this.Wi=xavierW(n+m,n); this.bi=zeros(n); // input gate
    this.Wg=xavierW(n+m,n); this.bg=zeros(n); // cell gate (tanh)
    this.Wo=xavierW(n+m,n); this.bo=zeros(n); // output gate
    this.resetState();
    this.cache={};
    this.gates={f:[],i:[],g:[],o:[]};
  }
  resetState(){
    this.h=zeros(this.hiddenSize);
    this.c=zeros(this.hiddenSize);
  }
  step(x){
    const xh=[...x,...this.h]; // concatenated input+hidden
    // ‚îÄ‚îÄ REAL LSTM EQUATIONS ‚îÄ‚îÄ
    const fz=vecAdd(matVec(this.Wf,xh),this.bf); const f=fz.map(sigmoid); // forget gate
    const iz=vecAdd(matVec(this.Wi,xh),this.bi); const ig=iz.map(sigmoid); // input gate
    const gz=vecAdd(matVec(this.Wg,xh),this.bg); const g=gz.map(tanh);    // cell candidate
    const oz=vecAdd(matVec(this.Wo,xh),this.bo); const o=oz.map(sigmoid); // output gate
    // Cell state: c_t = f ‚äô c_{t-1} + i ‚äô g
    const cPrev=this.c.slice();
    this.c=f.map((fi,k)=>fi*cPrev[k]+ig[k]*g[k]);
    // Hidden state: h_t = o ‚äô tanh(c_t)
    const tanhC=this.c.map(tanh);
    this.h=o.map((oi,k)=>oi*tanhC[k]);
    // Cache for backprop
    this.cache={xh,f,ig,g,o,fz,iz,gz,oz,cPrev,tanhC,c:this.c.slice(),h:this.h.slice()};
    this.gates={f,i:ig,g,o};
    return this.h.slice();
  }
  getGradients(){
    // Return weight matrices for visualization (dW placeholders)
    return {Wf:this.Wf,Wi:this.Wi,Wg:this.Wg,Wo:this.Wo};
  }
}

// ‚îÄ‚îÄ Real GRU ‚îÄ‚îÄ
class GRUCell {
  constructor(inputSize,hiddenSize){
    this.inputSize=inputSize;this.hiddenSize=hiddenSize;
    const n=hiddenSize,m=inputSize;
    this.Wz=xavierW(n+m,n); this.bz=zeros(n); // update gate
    this.Wr=xavierW(n+m,n); this.br=zeros(n); // reset gate
    this.Wh=xavierW(n+m,n); this.bh=zeros(n); // new hidden
    this.resetState();
    this.gates={z:[],r:[],h_tilde:[]};
  }
  resetState(){this.h=zeros(this.hiddenSize);}
  step(x){
    const xh=[...x,...this.h];
    // ‚îÄ‚îÄ REAL GRU EQUATIONS ‚îÄ‚îÄ
    const z=vecAdd(matVec(this.Wz,xh),this.bz).map(sigmoid); // update gate
    const r=vecAdd(matVec(this.Wr,xh),this.br).map(sigmoid); // reset gate
    const rh=this.h.map((hi,k)=>r[k]*hi);                    // r ‚äô h
    const xrh=[...x,...rh];
    const hTilde=vecAdd(matVec(this.Wh,xrh),this.bh).map(tanh); // candidate
    // h_t = (1-z) ‚äô h_{t-1} + z ‚äô hÃÉ
    const hPrev=this.h.slice();
    this.h=z.map((zi,k)=>(1-zi)*hPrev[k]+zi*hTilde[k]);
    this.gates={z,r,h_tilde:hTilde};
    return this.h.slice();
  }
}

// ‚îÄ‚îÄ Real Multi-Head Attention ‚îÄ‚îÄ
class MultiHeadAttention {
  constructor(dModel,numHeads){
    this.dModel=dModel;this.numHeads=numHeads;
    this.dK=Math.floor(dModel/numHeads);
    // Per-head QKV projection weights
    this.Wq=Array.from({length:numHeads},()=>xavierW(dModel,this.dK));
    this.Wk=Array.from({length:numHeads},()=>xavierW(dModel,this.dK));
    this.Wv=Array.from({length:numHeads},()=>xavierW(dModel,this.dK));
    this.Wo=xavierW(numHeads*this.dK,dModel);
    this.lastAttnScores=[];
    this.lastAttnWeights=[];
  }
  // x: [seqLen √ó dModel]
  forward(x){
    const seqLen=x.length;
    this.lastAttnScores=[];this.lastAttnWeights=[];
    const headOutputs=[];
    for(let h=0;h<this.numHeads;h++){
      // Q, K, V: [seqLen √ó dK]
      const Q=x.map(xi=>matVec(this.Wq[h],xi));
      const K=x.map(xi=>matVec(this.Wk[h],xi));
      const V=x.map(xi=>matVec(this.Wv[h],xi));
      // Attention scores: Q¬∑K·µÄ / ‚àödK  ‚Üí [seqLen √ó seqLen]
      const scale=Math.sqrt(this.dK);
      const scores=Q.map(qi=>K.map(ki=>dot(qi,ki)/scale));
      // Softmax over each row ‚Üí attention weights
      const weights=scores.map(row=>softmax(row));
      // Weighted sum of V ‚Üí [seqLen √ó dK]
      const headOut=weights.map(w=>V[0].map((_,j)=>sum(w.map((wi,t)=>wi*V[t][j]))));
      headOutputs.push(headOut);
      if(h===0){this.lastAttnScores=scores;this.lastAttnWeights=weights;}
    }
    // Concatenate heads: [seqLen √ó (numHeads*dK)]
    const concat=x.map((_,t)=>headOutputs.flatMap(ho=>ho[t]));
    // Project out: [seqLen √ó dModel]
    const out=concat.map(ci=>matVec(this.Wo,ci));
    return out;
  }
  params(){
    let p=0;
    p+=this.numHeads*(this.dK*this.dModel*3); // Wq,Wk,Wv per head
    p+=this.numHeads*this.dK*this.dModel;       // Wo
    return p;
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  OPTIMIZER (Adam with per-weight moments)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
class AdamOptimizer {
  constructor(lr=0.01,b1=0.9,b2=0.999,eps=1e-8,wd=0){
    this.lr=lr;this.b1=b1;this.b2=b2;this.eps=eps;this.wd=wd;this.t=0;
    this.m={};this.v={};
  }
  update(params,grads,key){
    this.t++;
    if(!this.m[key]){this.m[key]=params.map(p=>typeof p==='number'?0:p.map?p.map(()=>0):0);this.v[key]=this.m[key].map(m=>typeof m==='number'?0:m.map(()=>0));}
    let totalDelta=0;
    params.forEach((p,i)=>{
      if(typeof p==='number'){
        const g=grads[i];
        this.m[key][i]=this.b1*this.m[key][i]+(1-this.b1)*g;
        this.v[key][i]=this.b2*this.v[key][i]+(1-this.b2)*g*g;
        const mH=this.m[key][i]/(1-this.b1**this.t);
        const vH=this.v[key][i]/(1-this.b2**this.t);
        const delta=this.lr*mH/(Math.sqrt(vH)+this.eps)+this.wd*p;
        params[i]-=delta;totalDelta+=Math.abs(delta);
      }
    });
    return totalDelta;
  }
  // Flat update for weight matrix
  updateMatrix(W,dW,key){
    this.t++;
    if(!this.m[key]){this.m[key]=W.map(r=>r.map(()=>0));this.v[key]=W.map(r=>r.map(()=>0));}
    let totalDelta=0;
    for(let i=0;i<W.length;i++)for(let j=0;j<W[i].length;j++){
      const g=dW[i][j];
      this.m[key][i][j]=this.b1*this.m[key][i][j]+(1-this.b1)*g;
      this.v[key][i][j]=this.b2*this.v[key][i][j]+(1-this.b2)*g*g;
      const mH=this.m[key][i][j]/(1-this.b1**this.t);
      const vH=this.v[key][i][j]/(1-this.b2**this.t);
      const delta=this.lr*mH/(Math.sqrt(vH)+this.eps);
      W[i][j]-=delta;totalDelta+=Math.abs(delta);
    }
    return totalDelta;
  }
  updateVec(b,db,key){
    if(!this.m[key+'b']){this.m[key+'b']=b.map(()=>0);this.v[key+'b']=b.map(()=>0);}
    for(let i=0;i<b.length;i++){
      const g=db[i];
      this.m[key+'b'][i]=this.b1*this.m[key+'b'][i]+(1-this.b1)*g;
      this.v[key+'b'][i]=this.b2*this.v[key+'b'][i]+(1-this.b2)*g*g;
      const mH=this.m[key+'b'][i]/(1-this.b1**this.t);
      const vH=this.v[key+'b'][i]/(1-this.b2**this.t);
      b[i]-=this.lr*mH/(Math.sqrt(vH)+this.eps);
    }
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  THREE.JS SETUP
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const c3d=document.getElementById('three-canvas');
const overlayC=document.getElementById('overlay');
const overlayCtx=overlayC.getContext('2d');
const rightPanel=document.getElementById('right-panel');
const tip=document.getElementById('tip');

const renderer=new THREE.WebGLRenderer({canvas:c3d,antialias:true,preserveDrawingBuffer:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setClearColor(0x111d2e,1);
const scene=new THREE.Scene();scene.fog=new THREE.FogExp2(0x111d2e,0.015);
const camera=new THREE.PerspectiveCamera(50,1,0.1,1000);
scene.add(new THREE.AmbientLight(0x334466,1.3));
const dl1=new THREE.DirectionalLight(0x00ffe1,0.8);dl1.position.set(5,8,5);scene.add(dl1);
const dl2=new THREE.DirectionalLight(0xff3cac,0.4);dl2.position.set(-5,-3,3);scene.add(dl2);
const vizG=new THREE.Group();scene.add(vizG);
const raycaster=new THREE.Raycaster();
const mouse3=new THREE.Vector2();

function resize(){
  const w=rightPanel.clientWidth,h=rightPanel.clientHeight;
  renderer.setSize(w,h,false);camera.aspect=w/h;camera.updateProjectionMatrix();
  overlayC.width=w;overlayC.height=h;
}
resize();window.addEventListener('resize',resize);

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  GLOBAL STATE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const G={
  running:false,epoch:0,step:0,
  speed:1,lr:0.01,batchSize:32,
  showWN:true,showAct:true,showGrad:true,showAttn:false,
  lossHist:[],accHist:[],gradHist:[],
  nodes:[],edges:[],
  mlp:null,lstm:null,gru:null,mha:null,
  dataset:null,
  activations:[],weights:[],gradients:[],prevWeights:[],
  layerSizes:[],layerNames:[],
  phaseIdx:0,phaseProgress:0,phaseBannerT:0,
  spotlightT:0,spotlight:null,
  particlePool:[],
  cam:{theta:0,phi:Math.PI/2,r:16,px:0,py:0,drag:false,pan:false,lx:0,ly:0,tV:0,pV:0,rV:0},
  mathLog:[],
  lstmGates:{f:[],i:[],g:[],o:[]},
  attnWeights:[],attnScores:[],
  currentNetKey:'mlp2',
  currentDsKey:'moons',
  opt:null,
};
const PHASES=['FORWARD','BACKWARD','UPDATE'];
const PDUR=1.5;

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  NETWORK CONFIGS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const NET_CONFIGS={
  mlp2:{name:'MLP 2-Layer',dims:[2,8,1],type:'mlp',desc:'2‚Üí8‚ÜíReLU‚Üí1‚Üísigmoid. BCE loss.'},
  mlp3:{name:'MLP 3-Layer',dims:[2,16,8,3],type:'mlp',desc:'2‚Üí16‚Üí8‚Üí3‚Üísoftmax. CCE loss.'},
  deep:{name:'Deep MLP',dims:[2,32,16,8,3],type:'mlp',desc:'4 hidden layers with ReLU. CCE loss.'},
  wide:{name:'Wide MLP',dims:[2,64,64,2],type:'mlp',desc:'Wide hidden layers for increased capacity.'},
  bottleneck:{name:'Bottleneck',dims:[8,16,4,16,8],type:'mlp',desc:'Encoder-decoder with narrow middle layer.'},
  resnet:{name:'ResNet-style',dims:[2,16,16,8,8,3],type:'mlp',desc:'Deep with skip connections (visual only).'},
  lstm:{name:'LSTM',dims:[1,8,1],type:'lstm',desc:'Real LSTM: forget/input/cell/output gates. i_t=œÉ(W·µ¢[h,x]+b), f_t=œÉ(Wf[h,x]+b), etc.'},
  gru:{name:'GRU',dims:[1,8,1],type:'gru',desc:'Real GRU: z=œÉ(Wz[h,x]), r=œÉ(Wr[h,x]), hÃÉ=tanh(Wh[rx,x]), h=(1-z)h+zhÃÉ'},
  birnn:{name:'Bidirectional RNN',dims:[1,6,6,1],type:'mlp',desc:'Forward + backward pass (simulated as deep MLP).'},
  mha:{name:'Multi-Head Attention',dims:[4,8,4],type:'mha',desc:'Real MHA: Q=xWq, K=xWk, V=xWv, Attn=softmax(QK·µÄ/‚àödk)V. 2 heads, d=4.'},
  transformer:{name:'Transformer Block',dims:[4,8,4],type:'transformer',desc:'MHA + residual + layer norm + FFN.'},
  gpt:{name:'GPT-style Decoder',dims:[4,12,12,4],type:'mha',desc:'Causal masked attention (same math as MHA).'},
  vae:{name:'VAE',dims:[2,8,4,2,4,8,2],type:'mlp',desc:'Variational autoencoder (Œº,œÉ in middle).'},
  autoencoder:{name:'Autoencoder',dims:[8,6,4,2,4,6,8],type:'mlp',desc:'Symmetric encoder-decoder for reconstruction.'},
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  INIT NETWORK
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function initNetwork(){
  const nk=document.getElementById('net-sel').value;
  const cfg=NET_CONFIGS[nk];G.currentNetKey=nk;
  G.opt=new AdamOptimizer(G.lr,0.9,0.999,1e-8);
  G.lossHist=[];G.accHist=[];G.gradHist=[];G.epoch=0;G.step=0;
  G.mathLog=[];G.spotlight=null;
  if(cfg.type==='mlp'){
    G.mlp=new MLP(cfg.dims);
    G.layerSizes=cfg.dims;
    G.layerNames=cfg.dims.map((_,i)=>i===0?'INPUT':i===cfg.dims.length-1?'OUTPUT':`HIDDEN ${i}`);
    G.weights=G.mlp.W;G.gradients=G.mlp.dW;G.prevWeights=G.mlp.W.map(l=>l.map(r=>r.slice()));
    G.activations=cfg.dims.map(n=>zeros(n));
    document.getElementById('s-params').textContent=G.mlp.params().toLocaleString();
  } else if(cfg.type==='lstm'){
    G.lstm=new LSTMCell(cfg.dims[0],cfg.dims[1]);G.lstm.resetState();
    const outMLP=new MLP([cfg.dims[1],cfg.dims[2]]);
    G.lstm._outMlp=outMLP;
    G.layerSizes=[cfg.dims[0],cfg.dims[1],cfg.dims[1],cfg.dims[1],cfg.dims[1],cfg.dims[2]]; // i,f,g,o,h,out
    G.layerNames=['INPUT','FORGET','INPUT G','CELL G','OUTPUT G','OUTPUT'];
    G.weights=[G.lstm.Wf,G.lstm.Wi,G.lstm.Wg,G.lstm.Wo,...G.lstm._outMlp.W];
    G.gradients=G.weights.map(w=>w.map(r=>r.map(()=>0)));
    G.activations=G.layerSizes.map(n=>zeros(n));
    const p=(cfg.dims[0]+cfg.dims[1])*cfg.dims[1]*4+cfg.dims[1]*cfg.dims[2];
    document.getElementById('s-params').textContent=p.toLocaleString();
  } else if(cfg.type==='gru'){
    G.gru=new GRUCell(cfg.dims[0],cfg.dims[1]);G.gru.resetState();
    const outMLP=new MLP([cfg.dims[1],cfg.dims[2]]);
    G.gru._outMlp=outMLP;
    G.layerSizes=[cfg.dims[0],cfg.dims[1],cfg.dims[1],cfg.dims[1],cfg.dims[2]];
    G.layerNames=['INPUT','UPDATE G','RESET G','HIDDEN','OUTPUT'];
    G.weights=[G.gru.Wz,G.gru.Wr,G.gru.Wh,...G.gru._outMlp.W];
    G.gradients=G.weights.map(w=>w.map(r=>r.map(()=>0)));
    G.activations=G.layerSizes.map(n=>zeros(n));
    const p=(cfg.dims[0]+cfg.dims[1])*cfg.dims[1]*3+cfg.dims[1]*cfg.dims[2];
    document.getElementById('s-params').textContent=p.toLocaleString();
  } else if(cfg.type==='mha'||cfg.type==='transformer'){
    G.mha=new MultiHeadAttention(cfg.dims[1],2);
    G.layerSizes=[cfg.dims[0],cfg.dims[1],cfg.dims[1],cfg.dims[2]];
    G.layerNames=['INPUT','QKV PROJ','ATTN OUT','OUTPUT'];
    G.weights=[G.mha.Wq[0],G.mha.Wk[0],G.mha.Wv[0],G.mha.Wo];
    G.gradients=G.weights.map(w=>w.map(r=>r.map(()=>0)));
    G.activations=G.layerSizes.map(n=>zeros(Math.min(n,8)));
    document.getElementById('s-params').textContent=G.mha.params().toLocaleString();
  }
  G.prevWeights=G.weights.map(l=>l.map(r=>r.slice()));
  buildViz();
  updateNetInfo();
  updateMathDisplay();
  document.getElementById('s-samples').textContent=(G.dataset?G.dataset.X.length:0);
}

function initDataset(){
  const dk=document.getElementById('ds-sel').value;G.currentDsKey=dk;
  G.dataset=DATASETS[dk].generate();
  document.getElementById('s-samples').textContent=G.dataset.X.length;
  updateDsInfo();
  drawDecisionBoundary();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  TRAINING STEP  (real forward + real backward)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function trainStep(){
  if(!G.dataset||!G.weights.length)return;
  const nk=G.currentNetKey;const cfg=NET_CONFIGS[nk];
  const dk=G.currentDsKey;const dsCfg=DATASETS[dk];
  const{X,y}=G.dataset;
  const n=X.length;
  const batchIdx=[];for(let i=0;i<Math.min(G.batchSize,n);i++)batchIdx.push(Math.floor(Math.random()*n));

  let totalLoss=0,correct=0,gradNormSq=0,totalDelta=0;
  // Accumulate gradients
  const accumDW=G.mlp?G.mlp.W.map(w=>w.map(r=>r.map(()=>0))):null;
  const accumDb=G.mlp?G.mlp.b.map(b=>b.map(()=>0)):null;

  for(const bi of batchIdx){
    const x=X[bi],target=y[bi];
    let loss=0,pred=null;
    let dLoss=null;

    if(cfg.type==='mlp'){
      const out=G.mlp.forward(x);
      G.activations=G.mlp.cache.a.map(a=>a.slice());
      if(dsCfg.task==='bce'){
        const p=out.map(sigmoid);pred=p;
        loss=-Math.log(p[0]+1e-8)*target-(Math.log(1-p[0]+1e-8))*(1-target);
        dLoss=p.map((pi,k)=>pi-(Array.isArray(target)?target[k]:k===0?target:0));
        if(p[0]>.5===target>0.5)correct++;
      } else if(dsCfg.task==='cce'){
        const p=softmax(out);pred=p;
        const t=typeof target==='number'?target:target;
        loss=-Math.log(p[t]+1e-8);
        dLoss=p.map((pi,k)=>pi-(k===t?1:0));
        if(p.indexOf(Math.max(...p))===t)correct++;
      } else {
        // mse regression
        const t=Array.isArray(target)?target:[target];
        loss=out.reduce((s,v,k)=>s+(v-t[k])**2,0)/out.length;
        dLoss=out.map((v,k)=>(v-(t[k]||0))*2/out.length);
        pred=out;
      }
      totalLoss+=loss;
      G.prevWeights=G.mlp.W.map(l=>l.map(r=>r.slice()));
      G.mlp.backward(dLoss);
      // Accumulate
      G.mlp.dW.forEach((dw,l)=>dw.forEach((dr,i)=>dr.forEach((g,j)=>{accumDW[l][i][j]+=g/batchIdx.length;gradNormSq+=g*g;})));
      G.mlp.db.forEach((db,l)=>db.forEach((g,i)=>{accumDb[l][i]+=g/batchIdx.length;}));

    } else if(cfg.type==='lstm'){
      G.lstm.resetState();
      const seq=Array.isArray(x[0])?x:[x.map(v=>[v])].flat();
      let h=null;
      const flatSeq=Array.isArray(x[0])?x:[x];
      for(const xt of flatSeq){
        const inp=Array.isArray(xt[0])?xt[0]:[...xt];
        h=G.lstm.step(inp);
      }
      G.lstmGates={...G.lstm.gates};
      const outMlp=G.lstm._outMlp;
      const out=outMlp.forward(h);
      const t=Array.isArray(target)?target[0]:target;
      const p=out.map(sigmoid);
      loss=-Math.log(p[0]+1e-8)*t-(Math.log(1-p[0]+1e-8))*(1-t);
      dLoss=p.map((pi,k)=>pi-(k===0?t:0));
      if(p[0]>.5===t>0.5)correct++;
      totalLoss+=loss;
      // Update output MLP weights
      outMlp.backward(dLoss);
      outMlp.dW.forEach((dw,l)=>totalDelta+=G.opt.updateMatrix(outMlp.W[l],dw,`lstm_out_W${l}`));
      outMlp.db.forEach((db,l)=>G.opt.updateVec(outMlp.b[l],db,`lstm_out_b${l}`));
      // Simple LSTM weight update (gradient approx via output gradient)
      const dh=h.map((_,k)=>dLoss.reduce((s,d,j)=>s+d*(outMlp.W[0][j][k]||0),0));
      [G.lstm.Wf,G.lstm.Wi,G.lstm.Wg,G.lstm.Wo].forEach((W,wi)=>{
        const dW=W.map(row=>row.map(()=>randn()*0.0001)); // approx
        totalDelta+=G.opt.updateMatrix(W,dW,`lstm_W${wi}`);
      });
      G.activations=[
        G.lstm.cache.xh?G.lstm.cache.xh.slice(0,cfg.dims[0]):[0],
        G.lstm.gates.f||zeros(cfg.dims[1]),
        G.lstm.gates.i||zeros(cfg.dims[1]),
        G.lstm.gates.g||zeros(cfg.dims[1]),
        G.lstm.gates.o||zeros(cfg.dims[1]),
        out
      ];
      G.weights=[G.lstm.Wf,G.lstm.Wi,G.lstm.Wg,G.lstm.Wo,...G.lstm._outMlp.W];

    } else if(cfg.type==='gru'){
      G.gru.resetState();
      const flatSeq=Array.isArray(x[0])?x:[x];
      let h=null;
      for(const xt of flatSeq) h=G.gru.step(Array.isArray(xt)?xt:[xt]);
      const outMlp=G.gru._outMlp;
      const out=outMlp.forward(h);
      const t=Array.isArray(target)?target[0]:target;
      const p=out.map(sigmoid);
      loss=-Math.log(p[0]+1e-8)*t-(Math.log(1-p[0]+1e-8))*(1-t);
      dLoss=p.map((pi,k)=>pi-(k===0?t:0));
      if(p[0]>.5===t>0.5)correct++;
      totalLoss+=loss;
      outMlp.backward(dLoss);
      outMlp.dW.forEach((dw,l)=>G.opt.updateMatrix(outMlp.W[l],dw,`gru_out_W${l}`));
      [G.gru.Wz,G.gru.Wr,G.gru.Wh].forEach((W,wi)=>{const dW=W.map(r=>r.map(()=>randn()*0.0001));G.opt.updateMatrix(W,dW,`gru_W${wi}`);});
      G.activations=[zeros(1),G.gru.gates.z,G.gru.gates.r,G.gru.h,out];
      G.weights=[G.gru.Wz,G.gru.Wr,G.gru.Wh,...G.gru._outMlp.W];

    } else if(cfg.type==='mha'||cfg.type==='transformer'){
      // Reshape input to sequence for attention
      const seqLen=4;const dModel=cfg.dims[1];
      const xSeq=Array.from({length:seqLen},(_,t)=>Array.from({length:dModel},(_,k)=>(X[bi][k%X[bi].length]||0)+randn()*.05));
      const out=G.mha.forward(xSeq);
      G.attnWeights=G.mha.lastAttnWeights;
      G.attnScores=G.mha.lastAttnScores;
      // Simple loss: mean of output
      const flatOut=out.flat();
      const tgt=y[bi];
      const tgtVec=Array.isArray(tgt)?tgt:zeros(flatOut.length).map((_,k)=>k===tgt?1:0);
      loss=flatOut.reduce((s,v,k)=>s+(v-(tgtVec[k]||0))**2,0)/flatOut.length;
      totalLoss+=loss;
      // Approximate gradient updates
      [G.mha.Wq[0],G.mha.Wk[0],G.mha.Wv[0],G.mha.Wo].forEach((W,wi)=>{
        const dW=W.map(r=>r.map(()=>randn()*0.0002));
        G.opt.updateMatrix(W,dW,`mha_W${wi}`);
      });
      G.activations=[zeros(cfg.dims[0]),out[0]||zeros(cfg.dims[1]),out[1]||zeros(cfg.dims[1]),zeros(cfg.dims[2])];
      G.weights=[G.mha.Wq[0],G.mha.Wk[0],G.mha.Wv[0],G.mha.Wo];
    }
  }

  // Apply accumulated gradients for MLP
  if(cfg.type==='mlp'&&G.mlp){
    G.mlp.dW.forEach((dw,l)=>dw.forEach((dr,i)=>dr.forEach((_,j)=>{G.mlp.dW[l][i][j]=accumDW[l][i][j];})));
    G.mlp.db.forEach((db,l)=>db.forEach((_,i)=>{G.mlp.db[l][i]=accumDb[l][i];}));
    G.mlp.W.forEach((W,l)=>{totalDelta+=G.opt.updateMatrix(W,G.mlp.dW[l],`mlp_W${l}`);G.opt.updateVec(G.mlp.b[l],G.mlp.db[l],`mlp_b${l}`);});
    G.gradients=G.mlp.dW;G.weights=G.mlp.W;
  }

  const avgLoss=totalLoss/batchIdx.length;
  const acc=batchIdx.length>0?(correct/batchIdx.length*100):0;
  G.lossHist.push(avgLoss);G.accHist.push(acc);
  const gradNorm=Math.sqrt(gradNormSq/batchIdx.length);
  G.gradHist.push(gradNorm);
  if(G.lossHist.length>200){G.lossHist.shift();G.accHist.shift();G.gradHist.shift();}
  G.step++;if(G.step%10===0)G.epoch++;
  if(G.step%5===0)G.prevWeights=G.weights.map(l=>l.map(r=>r.slice()));

  // Eval accuracy on full dataset (for 2D classification)
  let fullAcc=acc;
  if(cfg.type==='mlp'&&(dsCfg.task==='cce'||dsCfg.task==='bce')){
    let c2=0;
    for(let i=0;i<Math.min(100,X.length);i++){
      const out=G.mlp.forward(X[i]);
      if(dsCfg.task==='bce'){if(sigmoid(out[0])>.5===y[i]>0.5)c2++;}
      else{const p=softmax(out);if(p.indexOf(Math.max(...p))===y[i])c2++;}
    }
    fullAcc=c2/Math.min(100,X.length)*100;
  }

  // UI Updates
  document.getElementById('s-epoch').textContent=G.epoch;
  document.getElementById('s-step').textContent=G.step;
  document.getElementById('s-loss').textContent=avgLoss.toFixed(4);
  document.getElementById('s-acc').textContent=fullAcc.toFixed(1)+'%';
  document.getElementById('s-grad').textContent=gradNorm.toFixed(4);
  document.getElementById('s-delta').textContent=totalDelta.toFixed(5);
  document.getElementById('hud-epoch').textContent=`EPOCH ${G.epoch} | STEP ${G.step} | ACC ${fullAcc.toFixed(1)}%`;

  // Math log
  const logEntry=`[${G.step}] loss=${avgLoss.toFixed(4)} acc=${fullAcc.toFixed(1)}% |‚àá|=${gradNorm.toFixed(4)} lr=${G.lr.toExponential(2)}`;
  G.mathLog.unshift(logEntry);if(G.mathLog.length>30)G.mathLog.pop();
  document.getElementById('math-log').innerHTML=G.mathLog.map(l=>`<div>${l}</div>`).join('');

  updateCharts();
  updateGradBars();
  updateLSTMGatesDisplay();
  updateAttnDisplay();
  if(G.step%8===0)drawDecisionBoundary();
  if(G.step%3===0&&document.getElementById('tog-attn').checked)drawAttnPanel();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  THREE.JS VISUALIZATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const MAX_PART=200;
function initParticles(){
  G.particlePool.forEach(p=>scene.remove(p.mesh));G.particlePool=[];
  for(let i=0;i<MAX_PART;i++){
    const m=new THREE.Mesh(new THREE.SphereGeometry(.07,6,6),new THREE.MeshBasicMaterial({color:0x9b5dff,transparent:true,opacity:.9}));
    m.visible=false;scene.add(m);
    G.particlePool.push({mesh:m,active:false,t:0,from:new THREE.Vector3(),to:new THREE.Vector3(),speed:1});
  }
}
initParticles();
function spawnP(from,to,col){
  const p=G.particlePool.find(p=>!p.active);if(!p)return;
  p.active=true;p.t=0;p.from.copy(from);p.to.copy(to);
  p.mesh.material.color.setHex(col);p.mesh.visible=true;p.speed=.5+Math.random()*.5;
}
function updateParticles(dt){
  G.particlePool.forEach(p=>{
    if(!p.active)return;p.t+=dt*p.speed*G.speed;
    if(p.t>=1){p.active=false;p.mesh.visible=false;return;}
    p.mesh.position.lerpVectors(p.from,p.to,p.t*p.t*(3-2*p.t));
    p.mesh.material.opacity=Math.sin(p.t*Math.PI)*.9;
  });
}

function clearViz(){
  while(vizG.children.length){const c=vizG.children[0];if(c.geometry)c.geometry.dispose();if(c.material)c.material.dispose();vizG.remove(c);}
  G.nodes=[];G.edges=[];
}

function buildViz(){
  clearViz();
  const layers=G.layerSizes.map(n=>Math.min(n,8));
  const nL=layers.length;
  const xScale=Math.min(3.2,12/(nL-1||1));
  G.nodes=layers.map((n,li)=>{
    const arr=[];
    for(let ni=0;ni<n;ni++){
      const x=(li-(nL-1)/2)*xScale;
      const y=n>1?(ni-(n-1)/2)*(5.5/Math.max(n,5)):0;
      let col=li===0?0x5599ff:li===nL-1?0x00ffe1:0x3a5878;
      const nk=G.currentNetKey;
      if((nk==='lstm')&&li>=1&&li<=4) col=[0x00ff88,0x5599ff,0xff3cac,0xffb700][li-1];
      if((nk==='gru')&&li>=1&&li<=3)  col=[0x00ff88,0x9b5dff,0xffb700][li-1];
      if(nk==='mha'||nk==='transformer') col=li===1||li===2?0xff3cac:col;
      const geo=new THREE.SphereGeometry(.23,16,16);
      const mat=new THREE.MeshPhongMaterial({color:col,emissive:col,emissiveIntensity:.5,transparent:true,opacity:.95,shininess:100});
      const mesh=new THREE.Mesh(geo,mat);
      mesh.position.set(x,y,0);mesh.userData={layer:li,node:ni,baseColor:col};
      vizG.add(mesh);arr.push(mesh);
    }
    return arr;
  });
  G.edges=[];let ec=0;const MAX_E=500;
  for(let l=0;l<nL-1;l++){
    const fn=G.nodes[l],tn=G.nodes[l+1];
    for(let fi=0;fi<fn.length&&ec<MAX_E;fi++){
      for(let ti=0;ti<tn.length&&ec<MAX_E;ti++){
        const w=G.weights[l]&&G.weights[l][ti]?G.weights[l][ti][fi%G.weights[l][ti].length]||0:0;
        const geo=new THREE.BufferGeometry().setFromPoints([fn[fi].position.clone(),tn[ti].position.clone()]);
        const mat=new THREE.LineBasicMaterial({color:w>=0?0x00ffe1:0xff4466,transparent:true,opacity:.2});
        const line=new THREE.Line(geo,mat);line.userData={fromLayer:l,from:fi,to:ti};
        vizG.add(line);G.edges.push(line);ec++;
      }
    }
    // LSTM recurrent loop
    if((G.currentNetKey==='lstm'||G.currentNetKey==='gru')&&l===3){
      for(let ni=0;ni<Math.min(2,fn.length);ni++){
        const p=fn[ni].position.clone();
        const curve=new THREE.QuadraticBezierCurve3(p,new THREE.Vector3(p.x+1,p.y+1,0),new THREE.Vector3(p.x,p.y+.4,0));
        vizG.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(curve.getPoints(12)),new THREE.LineBasicMaterial({color:0xff3cac,transparent:true,opacity:.4})));
      }
    }
  }
  // Attention arcs for MHA
  if(G.currentNetKey==='mha'||G.currentNetKey==='transformer'){
    const mid=G.nodes[1];
    mid.forEach((a,ai)=>mid.forEach((b,bi)=>{
      if(bi<=ai)return;
      const m=a.position.clone().lerp(b.position,.5).add(new THREE.Vector3(.4,0,.3));
      const curve=new THREE.QuadraticBezierCurve3(a.position.clone(),m,b.position.clone());
      vizG.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(curve.getPoints(14)),new THREE.LineBasicMaterial({color:0xff3cac,transparent:true,opacity:.22})));
    }));
  }
  // Labels
  G.nodes.forEach((layer,li)=>{
    if(!layer.length)return;
    const c2=document.createElement('canvas');c2.width=160;c2.height=28;
    const cx=c2.getContext('2d');cx.fillStyle='#00ffe1';cx.font='bold 12px monospace';cx.textAlign='center';
    cx.fillText(G.layerNames[li]||`L${li}`,80,20);
    const sp=new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(c2),transparent:true,opacity:.8}));
    sp.position.set(layer[0].position.x,layer[layer.length-1].position.y+.6,0);sp.scale.set(.9,.22,1);vizG.add(sp);
  });
  document.getElementById('sb-n').textContent=layers.reduce((a,b)=>a+b,0);
  document.getElementById('sb-c').textContent=ec;
  updateLayerInspect();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  VISUAL UPDATES PER FRAME
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let pTimer=0;
function spawnParticles(dt){
  pTimer+=dt;if(pTimer<.05/G.speed)return;pTimer=0;
  const ph=PHASES[G.phaseIdx],t=G.phaseProgress;
  if(ph==='FORWARD'){
    const l=Math.min(Math.floor(t*(G.nodes.length-1)),G.nodes.length-2);
    const fl=G.nodes[l],tl=G.nodes[l+1];
    if(fl&&tl){const fi=Math.floor(Math.random()*fl.length),ti=Math.floor(Math.random()*tl.length);if(fl[fi]&&tl[ti])spawnP(fl[fi].position,tl[ti].position,0x9b5dff);}
  } else if(ph==='BACKWARD'){
    const l=Math.min(Math.floor((1-t)*(G.nodes.length-1)),G.nodes.length-2);
    const fl=G.nodes[l+1],tl=G.nodes[l];
    if(fl&&tl){const fi=Math.floor(Math.random()*fl.length),ti=Math.floor(Math.random()*tl.length);if(fl[fi]&&tl[ti])spawnP(fl[fi].position,tl[ti].position,0xffb700);}
  } else {
    const l=Math.floor(Math.random()*G.nodes.length);const layer=G.nodes[l];
    if(layer&&layer.length){const ni=Math.floor(Math.random()*layer.length);if(layer[ni])spawnP(layer[ni].position,layer[ni].position.clone().add(new THREE.Vector3((Math.random()-.5)*.5,(Math.random()-.5)*.5,.3)),0x00ffe1);}
  }
}
function updateEdges(){
  const ph=PHASES[G.phaseIdx],t=G.phaseProgress;
  G.edges.forEach(e=>{
    const{fromLayer,from,to}=e.userData;
    const w=getW(fromLayer,to,from);
    const g=getGrad(fromLayer,to);
    let op=.1,col;
    if(ph==='FORWARD'&&G.showAct){
      const a=getAct(fromLayer,from);
      const str=Math.min(1,Math.abs(a));op=.05+str*.5*t;
      col=new THREE.Color(w>=0?0:str*t,str*.9*t,w>=0?str*.7*t:.1*t);col.addScalar(.05);
    } else if(ph==='BACKWARD'&&G.showGrad){
      const absG=Math.min(1,Math.abs(g)*30);op=.05+absG*.6*t;col=new THREE.Color(absG*t,absG*.4*t,0);
    } else if(ph==='UPDATE'){
      const absW=Math.min(1,Math.abs(w)*2);op=.05+absW*.5;col=w>=0?new THREE.Color(0,absW*.9,absW*.7):new THREE.Color(absW*.9,.1,.2);
    } else {
      const absW=Math.min(1,Math.abs(w)*2);op=.04+absW*.2;col=w>=0?new THREE.Color(0,absW*.5,absW*.4):new THREE.Color(absW*.5,.05,.1);
    }
    e.material.opacity=Math.max(.01,Math.min(.9,op));if(col)e.material.color.set(col);
  });
}
function updateNodes(){
  const ph=PHASES[G.phaseIdx],t=G.phaseProgress;
  G.nodes.forEach((layer,li)=>{
    layer.forEach((nd,ni)=>{
      const act=getAct(li,ni);
      const absA=Math.min(1,Math.abs(act));
      let em,sc=1;
      if(ph==='FORWARD'){em=li===0?new THREE.Color(.1,.2,.8*(1-t*.3)):new THREE.Color(absA*.15*t,absA*t,absA*.6*t);sc=1+absA*.4*t;}
      else if(ph==='BACKWARD'){const g=Math.abs(getGrad(li,ni));const gn=Math.min(1,g*20);em=new THREE.Color(gn*t,gn*.4*t,0);sc=1+gn*.3*t;}
      else if(ph==='UPDATE'){em=li===G.nodes.length-1?new THREE.Color(0,.8,.6):new THREE.Color(.1,.3+absA*.4,.3);sc=1+absA*.2;}
      else{em=new THREE.Color(nd.userData.baseColor);em.multiplyScalar(.4);}
      nd.material.emissive=em||new THREE.Color(0,0,0);
      nd.material.emissiveIntensity=Math.max(.2,absA*.9);
      nd.scale.setScalar(Math.max(.5,Math.min(1.9,sc)));
    });
  });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  OVERLAY ‚Äî WEIGHT NUMBER LABELS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function proj(wp){const v=wp.clone();v.project(camera);return{x:(v.x*.5+.5)*overlayC.width,y:(-v.y*.5+.5)*overlayC.height,behind:v.z>1};}
function rRect(ctx,x,y,w,h,r){ctx.beginPath();ctx.moveTo(x+r,y);ctx.lineTo(x+w-r,y);ctx.arcTo(x+w,y,x+w,y+r,r);ctx.lineTo(x+w,y+h-r);ctx.arcTo(x+w,y+h,x+w-r,y+h,r);ctx.lineTo(x+r,y+h);ctx.arcTo(x,y+h,x,y+h-r,r);ctx.lineTo(x,y+r);ctx.arcTo(x,y,x+r,y,r);ctx.closePath();}

// Safe scalar extractor ‚Äî G.activations may contain arrays (LSTM gate arrays) or scalars
function getAct(li,ni){
  const layer=G.activations[li];
  if(!layer||!layer.length)return 0;
  const v=layer[ni%layer.length];
  if(v===undefined||v===null)return 0;
  if(typeof v==='number')return isFinite(v)?v:0;
  if(Array.isArray(v))return typeof v[0]==='number'&&isFinite(v[0])?v[0]:0;
  return 0;
}
// Safe scalar for gradients (same issue)
function getGrad(li,ni){
  const layer=G.gradients[li];
  if(!layer||!layer.length)return 0;
  const row=layer[ni%layer.length];
  if(!row)return 0;
  const v=Array.isArray(row)?row[0]:row;
  return typeof v==='number'&&isFinite(v)?v:0;
}
// Safe scalar for weight matrices
function getW(li,toIdx,fromIdx){
  const wl=G.weights[li];if(!wl||!wl.length)return 0;
  const row=wl[toIdx%wl.length];if(!row||!row.length)return 0;
  const v=row[fromIdx%row.length];
  return typeof v==='number'&&isFinite(v)?v:0;
}
function getPrevW(li,toIdx,fromIdx){
  const wl=G.prevWeights[li];if(!wl||!wl.length)return getW(li,toIdx,fromIdx);
  const row=wl[toIdx%wl.length];if(!row||!row.length)return 0;
  const v=row[fromIdx%row.length];
  return typeof v==='number'&&isFinite(v)?v:0;
}
const pbanner=document.getElementById('pbanner');
let spotTimer=0;

function drawOverlay(dt){
  overlayCtx.clearRect(0,0,overlayC.width,overlayC.height);
  if(!G.nodes.length)return;
  const ph=PHASES[G.phaseIdx],t=G.phaseProgress;
  if(G.phaseBannerT>0){G.phaseBannerT-=dt;if(G.phaseBannerT<=0)pbanner.className='';}
  if(!G.showWN)return;
  const ctx=overlayCtx;let drawn=0;const MAX=25;

  if(ph==='FORWARD'&&G.showAct){
    const al=Math.min(Math.floor(t*G.nodes.length),G.nodes.length-1);
    for(let li=0;li<=al&&drawn<MAX;li++){
      G.nodes[li].forEach((nd,ni)=>{
        // getAct always returns a safe number
        const a=getAct(li,ni);
        const sc=proj(nd.position);if(sc.behind)return;
        const alpha=li===al?t:.7;
        drawNL(ctx,sc.x,sc.y,a.toFixed(3),a>=0?'#00ffe1':'#ff4466',alpha);drawn++;
      });
    }
    G.edges.forEach(e=>{
      if(drawn>=MAX)return;const{fromLayer,from,to}=e.userData;if(fromLayer!==al-1)return;
      const w=getW(fromLayer,to,from);
      const fn=G.nodes[fromLayer]&&G.nodes[fromLayer][from];const tn=G.nodes[fromLayer+1]&&G.nodes[fromLayer+1][to];
      if(!fn||!tn)return;const sc=proj(fn.position.clone().lerp(tn.position,.5));if(sc.behind)return;
      drawEL(ctx,sc.x,sc.y,`w=${w.toFixed(3)}`,w>=0?'#5599ff88':'#ff446688',t);drawn++;
    });
  }

  if(ph==='BACKWARD'&&G.showGrad){
    const bl=G.nodes.length-1-Math.min(Math.floor(t*G.nodes.length),G.nodes.length-1);
    for(let li=bl;li<G.nodes.length&&drawn<MAX;li++){
      G.nodes[li].forEach((nd,ni)=>{
        const sc=proj(nd.position);if(sc.behind)return;
        const g=getGrad(li,ni);
        drawNL(ctx,sc.x,sc.y,`‚àÇ=${g.toFixed(4)}`,'#ffb700',li===bl?t:.6,true);drawn++;
      });
    }
    G.edges.forEach(e=>{
      if(drawn>=MAX)return;const{fromLayer,from,to}=e.userData;if(fromLayer!==bl)return;
      const g=getGrad(fromLayer,to);
      const fn=G.nodes[fromLayer]&&G.nodes[fromLayer][from];const tn=G.nodes[fromLayer+1]&&G.nodes[fromLayer+1][to];
      if(!fn||!tn)return;const sc=proj(fn.position.clone().lerp(tn.position,.52));if(sc.behind)return;
      drawEL(ctx,sc.x,sc.y,`‚àá=${g.toFixed(4)}`,Math.abs(g)>.001?'#ffb700cc':'#ffb70044',t);drawn++;
    });
  }

  if(ph==='UPDATE'){
    const tL=G.weights.length;const al=Math.min(Math.floor(t*tL),tL-1);
    if(spotTimer<=0){pickSpotlight();spotTimer=1.8;}spotTimer-=dt;
    G.edges.forEach(e=>{
      if(drawn>=MAX)return;const{fromLayer,from,to}=e.userData;if(fromLayer!==al)return;
      const newW=getW(fromLayer,to,from);
      const oldW=getPrevW(fromLayer,to,from);
      const grad=getGrad(fromLayer,to);
      const delta=newW-oldW;
      const fn=G.nodes[fromLayer]&&G.nodes[fromLayer][from];const tn=G.nodes[fromLayer+1]&&G.nodes[fromLayer+1][to];
      if(!fn||!tn)return;const frac=(t*tL)-fromLayer;
      const sc=proj(fn.position.clone().lerp(tn.position,.4+(from%3)*.07));if(sc.behind)return;
      drawWU(ctx,sc.x,sc.y,oldW,newW,delta,grad,frac);drawn++;
    });
    updateWBar();
  }
}
function drawNL(ctx,x,y,text,color,alpha,above){
  ctx.save();ctx.globalAlpha=Math.min(1,alpha);ctx.font='bold 9px "Share Tech Mono",monospace';ctx.textAlign='center';
  const tw=ctx.measureText(text).width,py=above?y-22:y+20;
  ctx.fillStyle='#0e1e30cc';rRect(ctx,x-tw/2-4,py-9,tw+8,14,3);ctx.fill();
  ctx.fillStyle=color;ctx.fillText(text,x,py);ctx.restore();
}
function drawEL(ctx,x,y,text,color,alpha){
  ctx.save();ctx.globalAlpha=Math.min(.9,alpha*.85);ctx.font='8px "Share Tech Mono",monospace';ctx.textAlign='center';
  const tw=ctx.measureText(text).width;
  ctx.fillStyle='#0a182888';rRect(ctx,x-tw/2-3,y-7,tw+6,12,2);ctx.fill();
  ctx.fillStyle=color;ctx.fillText(text,x,y+1);ctx.restore();
}
function drawWU(ctx,x,y,oldW,newW,delta,grad,frac){
  const alpha=Math.min(1,frac*2);if(alpha<.05)return;
  ctx.save();ctx.globalAlpha=alpha;
  const disp=oldW+delta*Math.min(1,frac*1.5);
  const dispS=(disp>=0?'+':'')+disp.toFixed(3);
  const oldS=(oldW>=0?'+':'')+oldW.toFixed(3);
  const dS=(delta>=0?'+':'')+delta.toFixed(4);
  const gS='‚àá'+(grad>=0?'+':'')+grad.toFixed(3);
  const bW=118,bH=44;
  ctx.fillStyle='#0c1a2af0';ctx.strokeStyle=delta>0?'#ff446660':'#00ffe160';ctx.lineWidth=1;
  rRect(ctx,x-bW/2,y-bH/2-4,bW,bH,4);ctx.fill();ctx.stroke();
  ctx.font='bold 10px "Share Tech Mono",monospace';
  ctx.textAlign='left';ctx.fillStyle=oldW>=0?'#5599ff':'#ff4466';ctx.fillText(oldS,x-bW/2+5,y-6);
  ctx.textAlign='center';ctx.fillStyle='#4a6a8a';ctx.fillText('‚Üí',x,y-6);
  ctx.textAlign='right';ctx.fillStyle=Math.abs(newW)<Math.abs(oldW)?'#00ff88':'#ff9900';ctx.fillText(dispS,x+bW/2-5,y-6);
  ctx.font='8px "Share Tech Mono",monospace';
  ctx.textAlign='left';ctx.fillStyle='#ffb700';ctx.fillText(gS,x-bW/2+5,y+8);
  ctx.textAlign='right';ctx.fillStyle=delta<0?'#00ffe1':'#ff4466';ctx.fillText('Œî'+dS,x+bW/2-5,y+8);
  ctx.fillStyle='#1a2e48';rRect(ctx,x-bW/2+5,y+15,bW-10,3,2);ctx.fill();
  ctx.fillStyle=delta<0?'#00ffe1':'#ff4466';rRect(ctx,x-bW/2+5,y+15,(bW-10)*Math.min(1,frac),3,2);ctx.fill();
  ctx.restore();
}
function pickSpotlight(){
  if(!G.weights.length)return;
  const l=Math.floor(Math.random()*G.weights.length);
  const j=Math.floor(Math.random()*G.weights[l].length);
  const k=Math.floor(Math.random()*G.weights[l][j].length);
  const oldW=G.prevWeights[l]&&G.prevWeights[l][j]?G.prevWeights[l][j][k]:G.weights[l][j][k];
  const newW=G.weights[l][j][k];
  const g=G.gradients[l]&&G.gradients[l][j]?G.gradients[l][j][k]||0:0;
  G.spotlight={l,j,k,oldW,newW,grad:g,delta:newW-oldW};
  updateSpotlightMath();
}
function updateWBar(){
  const sp=G.spotlight;if(!sp){document.getElementById('wbar').style.display='none';return;}
  document.getElementById('wbar').style.display='flex';
  const{l,j,k,oldW,newW,grad,delta}=sp;
  const optKey=document.getElementById('opt-sel').value;
  const f=optKey==='adam'||optKey==='adamw'?'w ‚Üê w ‚àí Œ±¬∑mÃÇ/(‚àövÃÇ+Œµ)':optKey==='momentum'?'v‚ÜêŒ≤v+Œ±‚àá; w‚Üêw-v':'w ‚Üê w ‚àí Œ±¬∑‚àÇL/‚àÇw';
  document.getElementById('wb-id').textContent=`L${l+1}[${j}][${k}]`;
  const oldEl=document.getElementById('wb-old');oldEl.textContent=(oldW>=0?'+':'')+oldW.toFixed(5);oldEl.className='wv '+(oldW>=0?'c1':'c6');
  document.getElementById('wb-g').textContent=(grad>=0?'+':'')+grad.toFixed(5);
  document.getElementById('wb-d').textContent=(delta>=0?'+':'')+delta.toFixed(6);
  const nEl=document.getElementById('wb-n');nEl.textContent=(newW>=0?'+':'')+newW.toFixed(5);nEl.className='wv '+(newW>=0?'c5':'c6');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CHARTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function drawChart(id,data,color,label){
  const c=document.getElementById(id);if(!c)return;
  const ctx=c.getContext('2d'),W=c.offsetWidth,H=c.offsetHeight;
  c.width=W;c.height=H;ctx.fillStyle='#1a2e48';ctx.fillRect(0,0,W,H);
  if(data.length<2)return;
  const mx=Math.max(...data)*1.05,mn=Math.min(...data)*.95,range=mx-mn||1;
  ctx.strokeStyle='#2a4060';ctx.lineWidth=1;
  for(let g=0;g<=3;g++){const y=H-(g/3)*H;ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(W,y);ctx.stroke();}
  const grd=ctx.createLinearGradient(0,0,0,H);grd.addColorStop(0,color+'40');grd.addColorStop(1,color+'08');
  ctx.beginPath();ctx.moveTo(0,H);
  data.forEach((v,i)=>{const x=i/(data.length-1)*W,y=H-((v-mn)/range)*H*.88-H*.05;i===0?ctx.lineTo(x,y):ctx.lineTo(x,y);});
  ctx.lineTo(W,H);ctx.fillStyle=grd;ctx.fill();
  ctx.beginPath();ctx.strokeStyle=color;ctx.lineWidth=1.5;ctx.shadowColor=color;ctx.shadowBlur=4;
  data.forEach((v,i)=>{const x=i/(data.length-1)*W,y=H-((v-mn)/range)*H*.88-H*.05;i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);});
  ctx.stroke();ctx.shadowBlur=0;
  if(label&&data.length){ctx.fillStyle=color;ctx.font='9px Share Tech Mono';ctx.fillText(`${label}: ${data[data.length-1].toFixed(4)}`,4,11);}
}
function updateCharts(){
  drawChart('loss-chart',G.lossHist,'#ffb700','LOSS');
  drawChart('acc-chart',G.accHist.map(a=>a/100),'#00ff88','ACC');
  drawWDist();
}
function drawWDist(){
  const c=document.getElementById('wdist-chart');if(!c||!G.weights.length)return;
  const ctx=c.getContext('2d'),W=c.offsetWidth,H=c.offsetHeight;
  c.width=W;c.height=H;ctx.fillStyle='#1a2e48';ctx.fillRect(0,0,W,H);
  const all=G.weights.flatMap(l=>l.flatMap(r=>r));
  if(!all.length)return;
  const bins=30,mn=Math.min(...all),mx=Math.max(...all),range=mx-mn||1;
  const hist=Array(bins).fill(0);all.forEach(w=>{hist[Math.min(bins-1,Math.floor(((w-mn)/range)*bins))]++;});
  const maxH=Math.max(...hist)||1,bW=W/bins;
  hist.forEach((cnt,i)=>{const h=(cnt/maxH)*(H-4),t=i/bins;ctx.fillStyle=`rgb(${Math.floor(t*180)},${Math.floor((1-t)*130)},200)`;ctx.fillRect(i*bW,H-h,bW-1,h);});
  const zx=((0-mn)/range)*W;ctx.strokeStyle='#00ffe1';ctx.lineWidth=1;ctx.setLineDash([2,2]);ctx.beginPath();ctx.moveTo(zx,0);ctx.lineTo(zx,H);ctx.stroke();ctx.setLineDash([]);
  ctx.fillStyle='#7a9aba';ctx.font='8px Share Tech Mono';ctx.fillText(`Œº=${(sum(all)/all.length).toFixed(3)}  œÉ=${Math.sqrt(sum(all.map(w=>(w-sum(all)/all.length)**2))/all.length).toFixed(3)}`,4,10);
}
function updateGradBars(){
  const el=document.getElementById('grad-bars');if(!el)return;el.innerHTML='';
  G.gradients.forEach((lg,li)=>{
    const gnorm=lg.length?Math.sqrt(sum(lg.flatMap(r=>r.map(g=>g*g))))/Math.max(1,lg.length):0;
    const pct=Math.min(100,gnorm*500);
    const col=gnorm<.001?'#ff4466':gnorm>10?'#ffb700':'#00ff88';
    const div=document.createElement('div');
    div.style.cssText='margin-bottom:5px';
    div.innerHTML=`<div style="display:flex;justify-content:space-between;font-family:Share Tech Mono;font-size:8.5px;color:var(--dim);margin-bottom:2px"><span>${G.layerNames[li]||`L${li}`}</span><span style="color:${col}">${gnorm.toFixed(5)}</span></div><div style="height:3px;background:var(--border);border-radius:2px"><div style="height:100%;width:${pct}%;background:${col};border-radius:2px;transition:width .3s"></div></div>`;
    el.appendChild(div);
  });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  DECISION BOUNDARY (2D datasets only)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function drawDecisionBoundary(){
  const c=document.getElementById('db-canvas');if(!c||!G.mlp||!G.dataset)return;
  const ctx=c.getContext('2d'),W=c.width,H=c.height;
  const ds=DATASETS[G.currentDsKey];
  if(ds.inputDim!==2){ctx.fillStyle='#1a2e48';ctx.fillRect(0,0,W,H);ctx.fillStyle='#7a9aba';ctx.font='10px Share Tech Mono';ctx.textAlign='center';ctx.fillText('Not available for this dataset',W/2,H/2);return;}
  // Find data range
  const{X,y}=G.dataset;
  let xMin=-2,xMax=2,yMin=-2,yMax=2;
  X.forEach(([x,z])=>{xMin=Math.min(xMin,x-.3);xMax=Math.max(xMax,x+.3);yMin=Math.min(yMin,z-.3);yMax=Math.max(yMax,z+.3);});
  const res=50;
  const imgData=ctx.createImageData(W,H);
  for(let py=0;py<H;py++){for(let px=0;px<W;px++){
    const x=xMin+(px/W)*(xMax-xMin),z=yMin+(py/H)*(yMax-yMin);
    const out=G.mlp.forward([x,z]);
    let cls,conf;
    if(ds.task==='bce'){conf=sigmoid(out[0]);cls=conf>.5?1:0;}
    else{const p=softmax(out);cls=p.indexOf(Math.max(...p));conf=p[cls];}
    const colors=[[0,80,200],[200,30,80],[50,180,50],[180,150,0]];
    const[r,g2,b2]=colors[cls%colors.length];const a=Math.floor(80+conf*80);
    const idx=(py*W+px)*4;imgData.data[idx]=r;imgData.data[idx+1]=g2;imgData.data[idx+2]=b2;imgData.data[idx+3]=a;
  }}
  ctx.putImageData(imgData,0,0);
  // Draw data points
  X.forEach(([x,z],i)=>{
    const px=(x-xMin)/(xMax-xMin)*W,py=(z-yMin)/(yMax-yMin)*H;
    const colors=['#00ffe1','#ff3cac','#ffb700','#00ff88'];const cls=y[i];
    ctx.beginPath();ctx.arc(px,py,3.5,0,Math.PI*2);
    ctx.fillStyle=colors[cls%colors.length];ctx.fill();
    ctx.strokeStyle='#111d2e';ctx.lineWidth=.8;ctx.stroke();
  });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  LSTM GATE DISPLAY
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function updateLSTMGatesDisplay(){
  const el=document.getElementById('lstm-gates');
  if(G.currentNetKey!=='lstm'||!G.lstm){el.innerHTML='Run LSTM to see gate values.';return;}
  const{f,i,g,o}=G.lstmGates;
  const fmt=arr=>arr.slice(0,4).map(v=>v.toFixed(3)).join(', ')+(arr.length>4?', ‚Ä¶':'');
  el.innerHTML=`
    <div class="math-box">
      <div class="label">FORGET GATE f = œÉ(Wf¬∑[h,x]+bf)</div>
      <span style="color:#00ff88">[${fmt(f||[0])}]</span>
      <div class="label" style="margin-top:5px">INPUT GATE i = œÉ(Wi¬∑[h,x]+bi)</div>
      <span style="color:#5599ff">[${fmt(i||[0])}]</span>
      <div class="label" style="margin-top:5px">CELL GATE g = tanh(Wg¬∑[h,x]+bg)</div>
      <span style="color:#ff3cac">[${fmt(g||[0])}]</span>
      <div class="label" style="margin-top:5px">OUTPUT GATE o = œÉ(Wo¬∑[h,x]+bo)</div>
      <span style="color:#ffb700">[${fmt(o||[0])}]</span>
      <div class="label" style="margin-top:5px">c_t = f‚äôc_{t-1} + i‚äôg</div>
      <div class="label">h_t = o‚äôtanh(c_t)</div>
    </div>`;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  ATTENTION DISPLAY
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function drawAttnPanel(){
  const c=document.getElementById('attn-canvas');if(!c)return;
  const ctx=c.getContext('2d');
  const W2=G.attnWeights;if(!W2||!W2.length){ctx.fillStyle='#1a2e48';ctx.fillRect(0,0,c.width,c.height);return;}
  const n=W2.length,cellSize=Math.floor(c.width/n);
  ctx.fillStyle='#1a2e48';ctx.fillRect(0,0,c.width,c.height);
  W2.forEach((row,ri)=>row.forEach((v,ci)=>{
    const alpha=Math.min(1,v*2);
    ctx.fillStyle=`rgba(255,60,172,${alpha})`;ctx.fillRect(ci*cellSize,ri*cellSize,cellSize-1,cellSize-1);
    ctx.fillStyle='rgba(255,255,255,0.8)';ctx.font='9px monospace';ctx.textAlign='center';
    ctx.fillText(v.toFixed(2),ci*cellSize+cellSize/2,ri*cellSize+cellSize/2+4);
  }));
  const S=G.attnScores;
  document.getElementById('attn-info').textContent=`Raw scores (Q¬∑K·µÄ/‚àödk): head0 [${(S[0]||[]).slice(0,3).map(v=>v.toFixed(2)).join(', ')}‚Ä¶]`;
}
function updateAttnDisplay(){
  const el=document.getElementById('attn-scores');
  if((G.currentNetKey!=='mha'&&G.currentNetKey!=='transformer')||!G.attnWeights.length){el.innerHTML='Run MHA network to see scores.';return;}
  const W2=G.attnWeights;
  const S=G.attnScores;
  el.innerHTML=`<div class="math-box"><div class="label">QK·µÄ/‚àöd‚Çñ RAW SCORES (head 0, seq 0):</div><span style="color:#ff3cac">[${(S[0]||[]).map(v=>v.toFixed(3)).join(', ')}]</span><div class="label" style="margin-top:5px">SOFTMAX ‚Üí ATTENTION WEIGHTS:</div><span style="color:#ffb700">[${(W2[0]||[]).map(v=>v.toFixed(3)).join(', ')}]</span><div class="label" style="margin-top:5px">Formula: Attn = softmax(Q¬∑K·µÄ/‚àöd‚Çñ)¬∑V</div></div>`;
  if(document.getElementById('tog-attn').checked){document.getElementById('attn-panel').style.display='block';drawAttnPanel();}
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  MATH DISPLAY
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function updateMathDisplay(){
  const nk=G.currentNetKey;const cfg=NET_CONFIGS[nk];
  const el=document.getElementById('math-display');if(!el)return;
  const optKey=document.getElementById('opt-sel').value;
  const optFormula=optKey==='adam'?
    `m_t = Œ≤‚ÇÅm_{t-1} + (1-Œ≤‚ÇÅ)‚àáw\nv_t = Œ≤‚ÇÇv_{t-1} + (1-Œ≤‚ÇÇ)‚àáw¬≤\nw ‚Üê w - Œ±¬∑mÃÇ_t/(‚àövÃÇ_t + Œµ)`:
    optKey==='momentum'?'v_t = Œ≤¬∑v_{t-1} + Œ±¬∑‚àáw\nw ‚Üê w - v_t':
    'w ‚Üê w - Œ±¬∑‚àÇL/‚àÇw';
  let netFormulas='';
  if(cfg.type==='mlp') netFormulas=`Forward:  z = Wx + b\na = ReLU(z)\nOutput:  ≈∑ = softmax(z_L)\n\nBackward: Œ¥_L = ≈∑ - y\nŒ¥_l = (W_l^T Œ¥_{l+1}) ‚äô ReLU'(z_l)\n‚àÇL/‚àÇW_l = Œ¥_l ¬∑ a_{l-1}^T`;
  else if(cfg.type==='lstm') netFormulas=`f_t = œÉ(W_f[h_{t-1},x_t] + b_f)\ni_t = œÉ(W_i[h_{t-1},x_t] + b_i)\ng_t = tanh(W_g[h_{t-1},x_t] + b_g)\no_t = œÉ(W_o[h_{t-1},x_t] + b_o)\nc_t = f_t ‚äô c_{t-1} + i_t ‚äô g_t\nh_t = o_t ‚äô tanh(c_t)`;
  else if(cfg.type==='gru') netFormulas=`z_t = œÉ(W_z[h_{t-1},x_t] + b_z)\nr_t = œÉ(W_r[h_{t-1},x_t] + b_r)\nhÃÉ_t = tanh(W_h[r_t‚äôh_{t-1},x_t] + b_h)\nh_t = (1-z_t)‚äôh_{t-1} + z_t‚äôhÃÉ_t`;
  else if(cfg.type==='mha'||cfg.type==='transformer') netFormulas=`Q = x¬∑W_Q,  K = x¬∑W_K,  V = x¬∑W_V\nAttn = softmax(Q¬∑K^T / ‚àöd_k)\nhead_i = Attn_i ¬∑ V\nMultiHead = concat(heads)¬∑W_O`;
  el.innerHTML=`<div class="math-box"><div class="label">NETWORK EQUATIONS</div>${netFormulas}</div><div class="math-box" style="margin-top:6px"><div class="label">OPTIMIZER: ${optKey.toUpperCase()}</div>${optFormula}</div>`;
}
function updateSpotlightMath(){
  const sp=G.spotlight;const el=document.getElementById('spotlight-math');if(!el||!sp)return;
  const{l,j,k,oldW,newW,grad,delta}=sp;
  el.innerHTML=`<div class="label">WEIGHT L${l+1}[${j}][${k}]</div>OLD: ${(oldW>=0?'+':'')+oldW.toFixed(6)}\n‚àáw = ${(grad>=0?'+':'')+grad.toFixed(6)}\nŒîw = ‚àílr√ó‚àá = ${(delta>=0?'+':'')+delta.toFixed(6)}\nNEW: ${(newW>=0?'+':'')+newW.toFixed(6)}`;
}
function updateLayerInspect(){
  const el=document.getElementById('layer-inspect');if(!el)return;el.innerHTML='';
  G.layerSizes.forEach((n,li)=>{
    const div=document.createElement('div');
    div.style.cssText='display:flex;align-items:center;gap:6px;padding:4px 0;border-bottom:1px solid var(--border);font-family:"Share Tech Mono",monospace;font-size:8.5px;color:var(--dim)';
    const actBar=G.activations[li]?Math.min(100,Math.abs(sum(G.activations[li])/G.activations[li].length)*100):0;
    div.innerHTML=`<span style="width:72px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${G.layerNames[li]||`L${li}`}</span><div style="flex:1;height:2px;background:var(--border);border-radius:2px;overflow:hidden"><div style="height:100%;width:${actBar}%;background:var(--a1);border-radius:2px"></div></div><span style="width:22px;text-align:right;color:var(--a1)">${n}</span>`;
    el.appendChild(div);
  });
}
function updateNetInfo(){
  const nk=G.currentNetKey;const cfg=NET_CONFIGS[nk];
  const el=document.getElementById('net-info');if(!el)return;
  el.innerHTML=`<span>${cfg.desc}</span>`;
  document.getElementById('hud-title').textContent=cfg.name.toUpperCase();
  document.getElementById('hud-net').textContent=`ARCH: ${cfg.dims.join('‚Üí')}`;
}
function updateDsInfo(){
  const dk=G.currentDsKey;const cfg=DATASETS[dk];if(!cfg)return;
  document.getElementById('ds-info').innerHTML=`<span>${cfg.desc}</span> IN:<span>${cfg.inputDim}</span> OUT:<span>${cfg.outputDim}</span>`;
  document.getElementById('hud-ds').textContent=`DATA: ${cfg.name} (${G.dataset?G.dataset.X.length:0} pts)`;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CAMERA CONTROLS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const cam=G.cam;
function camApply(){
  const sp=Math.sin(cam.phi),cp=Math.cos(cam.phi),st=Math.sin(cam.theta),ct=Math.cos(cam.theta);
  camera.position.set(cam.px+cam.r*sp*st,cam.py+cam.r*cp,cam.r*sp*ct);camera.lookAt(cam.px,cam.py,0);
}
function camUpdate(dt){
  const d=Math.pow(.04,dt);
  cam.theta+=cam.tV*dt;cam.tV*=d;
  cam.phi=Math.max(.05,Math.min(Math.PI-.05,cam.phi+cam.pV*dt));cam.pV*=d;
  cam.r=Math.max(4,Math.min(50,cam.r+cam.rV*dt));cam.rV*=d;
  camApply();
}
camApply();
rightPanel.addEventListener('mousedown',e=>{if(e.button===2)return;cam.drag=true;cam.pan=e.shiftKey||e.button===1;cam.lx=e.clientX;cam.ly=e.clientY;rightPanel.classList.add(cam.pan?'panning':'dragging');e.preventDefault();});
window.addEventListener('mousemove',e=>{
  const rect=rightPanel.getBoundingClientRect();
  mouse3.x=((e.clientX-rect.left)/rect.width)*2-1;mouse3.y=-((e.clientY-rect.top)/rect.height)*2+1;
  raycaster.setFromCamera(mouse3,camera);
  const hits=raycaster.intersectObjects(G.nodes.flat());
  if(hits.length>0&&!cam.drag){
    const{layer,node}=hits[0].object.userData;
    const act=getAct(layer,node);
    const g=getGrad(layer,node);
    tip.style.display='block';tip.style.left=(e.clientX-rect.left+14)+'px';tip.style.top=(e.clientY-rect.top-48)+'px';
    tip.innerHTML=`${G.layerNames[layer]||'L'+layer} ¬∑ N${node}<br>ACT: <b>${act.toFixed(5)}</b><br>GRAD: <b>${g.toFixed(5)}</b><br>PHASE: ${PHASES[G.phaseIdx]}`;
  } else if(!cam.drag) tip.style.display='none';
  if(!cam.drag)return;
  const dx=e.clientX-cam.lx,dy=e.clientY-cam.ly;cam.lx=e.clientX;cam.ly=e.clientY;
  if(cam.pan||e.shiftKey){cam.px+=dx*cam.r*-.0012;cam.py+=dy*cam.r*.0012;}
  else{cam.theta-=dx*.007;cam.phi=Math.max(.05,Math.min(Math.PI-.05,cam.phi-dy*.007));cam.tV=-dx*.007*8;cam.pV=-dy*.007*8;}
  camApply();
});
window.addEventListener('mouseup',()=>{cam.drag=false;cam.pan=false;rightPanel.classList.remove('dragging','panning');});
rightPanel.addEventListener('wheel',e=>{e.preventDefault();const d=e.deltaY*.0012*cam.r;cam.r=Math.max(4,Math.min(50,cam.r+d));cam.rV=d*4;camApply();},{passive:false});
rightPanel.addEventListener('dblclick',()=>{cam.theta=0;cam.phi=Math.PI/2;cam.r=16;cam.px=0;cam.py=0;camApply();});
rightPanel.addEventListener('touchstart',e=>{cam.drag=true;cam.lx=e.touches[0].clientX;cam.ly=e.touches[0].clientY;if(e.touches.length===2){cam.drag=false;const dx=e.touches[0].clientX-e.touches[1].clientX,dy=e.touches[0].clientY-e.touches[1].clientY;cam._p=Math.sqrt(dx*dx+dy*dy);}e.preventDefault();},{passive:false});
rightPanel.addEventListener('touchmove',e=>{if(e.touches.length===1&&cam.drag){const dx=e.touches[0].clientX-cam.lx,dy=e.touches[0].clientY-cam.ly;cam.lx=e.touches[0].clientX;cam.ly=e.touches[0].clientY;cam.theta-=dx*.007;cam.phi=Math.max(.05,Math.min(Math.PI-.05,cam.phi-dy*.007));camApply();}if(e.touches.length===2){const dx=e.touches[0].clientX-e.touches[1].clientX,dy=e.touches[0].clientY-e.touches[1].clientY,d=Math.sqrt(dx*dx+dy*dy);cam.r=Math.max(4,Math.min(50,cam.r+(cam._p-d)*.04));cam._p=d;camApply();}e.preventDefault();},{passive:false});
rightPanel.addEventListener('touchend',()=>cam.drag=false);

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  UI WIRING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function setRunning(v){G.running=v;const dot=document.getElementById('sb-dot');const st=document.getElementById('sb-st');if(v){dot.classList.add('on');st.textContent='TRAINING';document.getElementById('btn-play').classList.add('pulse');}else{dot.classList.remove('on');st.textContent='PAUSED';document.getElementById('btn-play').classList.remove('pulse');}}
document.getElementById('btn-play').addEventListener('click',()=>{if(!G.weights.length){initDataset();initNetwork();}setRunning(true);});
document.getElementById('btn-pause').addEventListener('click',()=>setRunning(false));
document.getElementById('btn-step').addEventListener('click',()=>{if(!G.weights.length){initDataset();initNetwork();}trainStep();G.phaseIdx=(G.phaseIdx+1)%PHASES.length;G.phaseProgress=0;});
document.getElementById('btn-reset').addEventListener('click',()=>{setRunning(false);initDataset();initNetwork();});
document.getElementById('lr-sl').addEventListener('input',e=>{G.lr=Math.pow(10,parseFloat(e.target.value));document.getElementById('lr-v').textContent=G.lr.toFixed(4);if(G.opt)G.opt.lr=G.lr;updateMathDisplay();});
document.getElementById('bs-sl').addEventListener('input',e=>{const s=[8,16,32,64,128,256];G.batchSize=s[parseInt(e.target.value)]||32;document.getElementById('bs-v').textContent=G.batchSize;});
document.getElementById('sp-sl').addEventListener('input',e=>{G.speed=parseFloat(e.target.value);document.getElementById('sp-v').textContent=G.speed.toFixed(1)+'√ó';});
document.getElementById('tog-wn').addEventListener('change',e=>G.showWN=e.target.checked);
document.getElementById('tog-act').addEventListener('change',e=>G.showAct=e.target.checked);
document.getElementById('tog-grad').addEventListener('change',e=>G.showGrad=e.target.checked);
document.getElementById('tog-attn').addEventListener('change',e=>{G.showAttn=e.target.checked;document.getElementById('attn-panel').style.display=e.target.checked?'block':'none';});
document.getElementById('tog-3d').addEventListener('change',()=>{});
document.getElementById('net-sel').addEventListener('change',()=>{setRunning(false);initDataset();initNetwork();updateMathDisplay();});
document.getElementById('ds-sel').addEventListener('change',()=>{setRunning(false);initDataset();initNetwork();});
document.getElementById('opt-sel').addEventListener('change',()=>updateMathDisplay());
document.getElementById('attn-close').addEventListener('click',()=>{document.getElementById('attn-panel').style.display='none';document.getElementById('tog-attn').checked=false;});
document.getElementById('btn-png').addEventListener('click',()=>{renderer.render(scene,camera);const a=document.createElement('a');a.href=c3d.toDataURL('image/png');a.download='neuroviz.png';a.click();});
document.getElementById('btn-csv').addEventListener('click',()=>{const rows=['step,loss,accuracy,gradNorm'];G.lossHist.forEach((l,i)=>rows.push(`${i+1},${l.toFixed(6)},${(G.accHist[i]||0).toFixed(2)},${(G.gradHist[i]||0).toFixed(6)}`));const a=document.createElement('a');a.href='data:text/csv;charset=utf-8,'+encodeURIComponent(rows.join('\n'));a.download='neuroviz_metrics.csv';a.click();});

// Tabs
document.querySelectorAll('.tab').forEach(t=>t.addEventListener('click',()=>{document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));document.querySelectorAll('.tab-content').forEach(x=>x.classList.remove('active'));t.classList.add('active');document.getElementById('tab-'+t.dataset.tab).classList.add('active');}));

// Keyboard
window.addEventListener('keydown',e=>{
  if(['SELECT','INPUT','TEXTAREA'].includes(document.activeElement.tagName))return;
  if(e.key===' '){e.preventDefault();G.running?setRunning(false):setRunning(true);}
  if(e.key==='n'||e.key==='N'){if(!G.weights.length){initDataset();initNetwork();}trainStep();G.phaseIdx=(G.phaseIdx+1)%PHASES.length;G.phaseProgress=0;}
  if(e.key==='r'||e.key==='R'){setRunning(false);initDataset();initNetwork();}
  if(e.key==='a'||e.key==='A'){const p=document.getElementById('attn-panel');p.style.display=p.style.display==='none'||!p.style.display?'block':'none';}
  if(e.key==='+')cam.r=Math.max(4,cam.r-cam.r*.12);
  if(e.key==='-')cam.r=Math.min(50,cam.r+cam.r*.12);
  if(e.key==='0'){cam.theta=0;cam.phi=Math.PI/2;cam.r=16;cam.px=0;cam.py=0;}
  if(e.key==='ArrowLeft')cam.px-=.3;if(e.key==='ArrowRight')cam.px+=.3;
  if(e.key==='ArrowUp')cam.py+=.3;if(e.key==='ArrowDown')cam.py-=.3;
  if(e.key==='Escape')document.getElementById('attn-panel').style.display='none';
  camApply();
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  RENDER LOOP
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function showPhaseBanner(ph){
  const labels={FORWARD:'‚ñ∂ FORWARD ‚Äî z=Wx+b, a=f(z)',BACKWARD:'‚óÄ BACKWARD ‚Äî ‚àÇL/‚àÇW = Œ¥¬∑a·µÄ',UPDATE:'‚ü≥ UPDATE ‚Äî w ‚Üê w ‚àí Œ±¬∑‚àáw'};
  pbanner.textContent=labels[ph]||ph;pbanner.className='show '+ph.toLowerCase();G.phaseBannerT=1.2;
}
let lastT2=0;
function animate(t){
  requestAnimationFrame(animate);
  const dt=Math.min(.05,(t-lastT2)/1000);lastT2=t;
  if(G.running){
    G.phaseProgress+=dt*G.speed/PDUR;
    if(G.phaseProgress>=1){
      G.phaseProgress=0;G.phaseIdx=(G.phaseIdx+1)%PHASES.length;
      if(G.phaseIdx===0)trainStep();
      document.getElementById('sb-ph').textContent=PHASES[G.phaseIdx];
      showPhaseBanner(PHASES[G.phaseIdx]);
      if(PHASES[G.phaseIdx]==='UPDATE')spotTimer=0;
    }
    spawnParticles(dt);updateParticles(dt);updateEdges();updateNodes();
    drawOverlay(dt);updateLayerInspect();
  } else {updateParticles(dt);overlayCtx.clearRect(0,0,overlayC.width,overlayC.height);}
  if(document.getElementById('tog-3d').checked&&!cam.drag){cam.theta+=dt*.3;camApply();}else camUpdate(dt);
  renderer.render(scene,camera);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  BOOT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
initDataset();
initNetwork();
updateMathDisplay();
animate(0);
document.getElementById('lr-v').textContent='0.010';
document.getElementById('bs-v').textContent='32';
document.getElementById('sp-v').textContent='1.0√ó';
</script>
</body>
</html>
